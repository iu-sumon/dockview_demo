{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n * Accreditation: This file is largly based upon the MIT licenced VSCode sourcecode found at:\n * https://github.com/microsoft/vscode/tree/main/src/vs/base/browser/ui/grid\n *--------------------------------------------------------------------------------------------*/\nimport { Orientation, Sizing } from '../splitview/splitview';\nimport { tail } from '../array';\nimport { LeafNode } from './leafNode';\nimport { BranchNode } from './branchNode';\nimport { Emitter } from '../events';\nimport { MutableDisposable } from '../lifecycle';\nfunction findLeaf(candiateNode, last) {\n  if (candiateNode instanceof LeafNode) {\n    return candiateNode;\n  }\n  if (candiateNode instanceof BranchNode) {\n    return findLeaf(candiateNode.children[last ? candiateNode.children.length - 1 : 0], last);\n  }\n  throw new Error('invalid node');\n}\nfunction flipNode(node, size, orthogonalSize) {\n  if (node instanceof BranchNode) {\n    const result = new BranchNode(orthogonal(node.orientation), node.proportionalLayout, node.styles, size, orthogonalSize, node.disabled, node.margin);\n    let totalSize = 0;\n    for (let i = node.children.length - 1; i >= 0; i--) {\n      const child = node.children[i];\n      const childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;\n      let newSize = node.size === 0 ? 0 : Math.round(size * childSize / node.size);\n      totalSize += newSize;\n      // The last view to add should adjust to rounding errors\n      if (i === 0) {\n        newSize += size - totalSize;\n      }\n      result.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);\n    }\n    return result;\n  } else {\n    return new LeafNode(node.view, orthogonal(node.orientation), orthogonalSize);\n  }\n}\nexport function indexInParent(element) {\n  const parentElement = element.parentElement;\n  if (!parentElement) {\n    throw new Error('Invalid grid element');\n  }\n  let el = parentElement.firstElementChild;\n  let index = 0;\n  while (el !== element && el !== parentElement.lastElementChild && el) {\n    el = el.nextElementSibling;\n    index++;\n  }\n  return index;\n}\n/**\n * Find the grid location of a specific DOM element by traversing the parent\n * chain and finding each child index on the way.\n *\n * This will break as soon as DOM structures of the Splitview or Gridview change.\n */\nexport function getGridLocation(element) {\n  const parentElement = element.parentElement;\n  if (!parentElement) {\n    throw new Error('Invalid grid element');\n  }\n  if (/\\bdv-grid-view\\b/.test(parentElement.className)) {\n    return [];\n  }\n  const index = indexInParent(parentElement);\n  const ancestor = parentElement.parentElement.parentElement.parentElement;\n  return [...getGridLocation(ancestor), index];\n}\nexport function getRelativeLocation(rootOrientation, location, direction) {\n  const orientation = getLocationOrientation(rootOrientation, location);\n  const directionOrientation = getDirectionOrientation(direction);\n  if (orientation === directionOrientation) {\n    const [rest, _index] = tail(location);\n    let index = _index;\n    if (direction === 'right' || direction === 'bottom') {\n      index += 1;\n    }\n    return [...rest, index];\n  } else {\n    const index = direction === 'right' || direction === 'bottom' ? 1 : 0;\n    return [...location, index];\n  }\n}\nexport function getDirectionOrientation(direction) {\n  return direction === 'top' || direction === 'bottom' ? Orientation.VERTICAL : Orientation.HORIZONTAL;\n}\nexport function getLocationOrientation(rootOrientation, location) {\n  return location.length % 2 === 0 ? orthogonal(rootOrientation) : rootOrientation;\n}\nexport const orthogonal = orientation => orientation === Orientation.HORIZONTAL ? Orientation.VERTICAL : Orientation.HORIZONTAL;\nexport function isGridBranchNode(node) {\n  return !!node.children;\n}\nconst serializeBranchNode = (node, orientation) => {\n  const size = orientation === Orientation.VERTICAL ? node.box.width : node.box.height;\n  if (!isGridBranchNode(node)) {\n    if (typeof node.cachedVisibleSize === 'number') {\n      return {\n        type: 'leaf',\n        data: node.view.toJSON(),\n        size: node.cachedVisibleSize,\n        visible: false\n      };\n    }\n    return {\n      type: 'leaf',\n      data: node.view.toJSON(),\n      size\n    };\n  }\n  return {\n    type: 'branch',\n    data: node.children.map(c => serializeBranchNode(c, orthogonal(orientation))),\n    size\n  };\n};\nexport class Gridview {\n  get length() {\n    return this._root ? this._root.children.length : 0;\n  }\n  get orientation() {\n    return this.root.orientation;\n  }\n  set orientation(orientation) {\n    if (this.root.orientation === orientation) {\n      return;\n    }\n    const {\n      size,\n      orthogonalSize\n    } = this.root;\n    this.root = flipNode(this.root, orthogonalSize, size);\n    this.root.layout(size, orthogonalSize);\n  }\n  get width() {\n    return this.root.width;\n  }\n  get height() {\n    return this.root.height;\n  }\n  get minimumWidth() {\n    return this.root.minimumWidth;\n  }\n  get minimumHeight() {\n    return this.root.minimumHeight;\n  }\n  get maximumWidth() {\n    return this.root.maximumHeight;\n  }\n  get maximumHeight() {\n    return this.root.maximumHeight;\n  }\n  get locked() {\n    return this._locked;\n  }\n  set locked(value) {\n    this._locked = value;\n    const branch = [this.root];\n    /**\n     * simple depth-first-search to cover all nodes\n     *\n     * @see https://en.wikipedia.org/wiki/Depth-first_search\n     */\n    while (branch.length > 0) {\n      const node = branch.pop();\n      if (node instanceof BranchNode) {\n        node.disabled = value;\n        branch.push(...node.children);\n      }\n    }\n  }\n  get margin() {\n    return this._margin;\n  }\n  set margin(value) {\n    this._margin = value;\n    this.root.margin = value;\n  }\n  maximizedView() {\n    var _a;\n    return (_a = this._maximizedNode) === null || _a === void 0 ? void 0 : _a.leaf.view;\n  }\n  hasMaximizedView() {\n    return this._maximizedNode !== undefined;\n  }\n  maximizeView(view) {\n    var _a;\n    const location = getGridLocation(view.element);\n    const [_, node] = this.getNode(location);\n    if (!(node instanceof LeafNode)) {\n      return;\n    }\n    if (((_a = this._maximizedNode) === null || _a === void 0 ? void 0 : _a.leaf) === node) {\n      return;\n    }\n    if (this.hasMaximizedView()) {\n      this.exitMaximizedView();\n    }\n    serializeBranchNode(this.getView(), this.orientation);\n    const hiddenOnMaximize = [];\n    function hideAllViewsBut(parent, exclude) {\n      for (let i = 0; i < parent.children.length; i++) {\n        const child = parent.children[i];\n        if (child instanceof LeafNode) {\n          if (child !== exclude) {\n            if (parent.isChildVisible(i)) {\n              parent.setChildVisible(i, false);\n            } else {\n              hiddenOnMaximize.push(child);\n            }\n          }\n        } else {\n          hideAllViewsBut(child, exclude);\n        }\n      }\n    }\n    hideAllViewsBut(this.root, node);\n    this._maximizedNode = {\n      leaf: node,\n      hiddenOnMaximize\n    };\n    this._onDidMaximizedNodeChange.fire({\n      view: node.view,\n      isMaximized: true\n    });\n  }\n  exitMaximizedView() {\n    if (!this._maximizedNode) {\n      return;\n    }\n    const hiddenOnMaximize = this._maximizedNode.hiddenOnMaximize;\n    function showViewsInReverseOrder(parent) {\n      for (let index = parent.children.length - 1; index >= 0; index--) {\n        const child = parent.children[index];\n        if (child instanceof LeafNode) {\n          if (!hiddenOnMaximize.includes(child)) {\n            parent.setChildVisible(index, true);\n          }\n        } else {\n          showViewsInReverseOrder(child);\n        }\n      }\n    }\n    showViewsInReverseOrder(this.root);\n    const tmp = this._maximizedNode.leaf;\n    this._maximizedNode = undefined;\n    this._onDidMaximizedNodeChange.fire({\n      view: tmp.view,\n      isMaximized: false\n    });\n  }\n  serialize() {\n    const maximizedView = this.maximizedView();\n    let maxmizedViewLocation;\n    if (maximizedView) {\n      /**\n       * The minimum information we can get away with in order to serialize a maxmized view is it's location within the grid\n       * which is represented as a branch of indices\n       */\n      maxmizedViewLocation = getGridLocation(maximizedView.element);\n    }\n    if (this.hasMaximizedView()) {\n      /**\n       * the saved layout cannot be in its maxmized state otherwise all of the underlying\n       * view dimensions will be wrong\n       *\n       * To counteract this we temporaily remove the maximized view to compute the serialized output\n       * of the grid before adding back the maxmized view as to not alter the layout from the users\n       * perspective when `.toJSON()` is called\n       */\n      this.exitMaximizedView();\n    }\n    const root = serializeBranchNode(this.getView(), this.orientation);\n    const resullt = {\n      root,\n      width: this.width,\n      height: this.height,\n      orientation: this.orientation\n    };\n    if (maxmizedViewLocation) {\n      resullt.maximizedNode = {\n        location: maxmizedViewLocation\n      };\n    }\n    if (maximizedView) {\n      // replace any maximzied view that was removed for serialization purposes\n      this.maximizeView(maximizedView);\n    }\n    return resullt;\n  }\n  dispose() {\n    this.disposable.dispose();\n    this._onDidChange.dispose();\n    this._onDidMaximizedNodeChange.dispose();\n    this._onDidViewVisibilityChange.dispose();\n    this.root.dispose();\n    this._maximizedNode = undefined;\n    this.element.remove();\n  }\n  clear() {\n    const orientation = this.root.orientation;\n    this.root = new BranchNode(orientation, this.proportionalLayout, this.styles, this.root.size, this.root.orthogonalSize, this.locked, this.margin);\n  }\n  deserialize(json, deserializer) {\n    const orientation = json.orientation;\n    const height = orientation === Orientation.VERTICAL ? json.height : json.width;\n    this._deserialize(json.root, orientation, deserializer, height);\n    /**\n     * The deserialied layout must be positioned through this.layout(...)\n     * before any maximizedNode can be positioned\n     */\n    this.layout(json.width, json.height);\n    if (json.maximizedNode) {\n      const location = json.maximizedNode.location;\n      const [_, node] = this.getNode(location);\n      if (!(node instanceof LeafNode)) {\n        return;\n      }\n      this.maximizeView(node.view);\n    }\n  }\n  _deserialize(root, orientation, deserializer, orthogonalSize) {\n    this.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize);\n  }\n  _deserializeNode(node, orientation, deserializer, orthogonalSize) {\n    var _a;\n    let result;\n    if (node.type === 'branch') {\n      const serializedChildren = node.data;\n      const children = serializedChildren.map(serializedChild => {\n        return {\n          node: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),\n          visible: serializedChild.visible\n        };\n      });\n      result = new BranchNode(orientation, this.proportionalLayout, this.styles, node.size,\n      // <- orthogonal size - flips at each depth\n      orthogonalSize,\n      // <- size - flips at each depth,\n      this.locked, this.margin, children);\n    } else {\n      const view = deserializer.fromJSON(node);\n      if (typeof node.visible === 'boolean') {\n        (_a = view.setVisible) === null || _a === void 0 ? void 0 : _a.call(view, node.visible);\n      }\n      result = new LeafNode(view, orientation, orthogonalSize, node.size);\n    }\n    return result;\n  }\n  get root() {\n    return this._root;\n  }\n  set root(root) {\n    const oldRoot = this._root;\n    if (oldRoot) {\n      oldRoot.dispose();\n      this._maximizedNode = undefined;\n      this.element.removeChild(oldRoot.element);\n    }\n    this._root = root;\n    this.element.appendChild(this._root.element);\n    this.disposable.value = this._root.onDidChange(e => {\n      this._onDidChange.fire(e);\n    });\n  }\n  /**\n   * If the root is orientated as a VERTICAL node then nest the existing root within a new HORIZIONTAL root node\n   * If the root is orientated as a HORIZONTAL node then nest the existing root within a new VERITCAL root node\n   */\n  insertOrthogonalSplitviewAtRoot() {\n    if (!this._root) {\n      return;\n    }\n    const oldRoot = this.root;\n    oldRoot.element.remove();\n    this._root = new BranchNode(orthogonal(oldRoot.orientation), this.proportionalLayout, this.styles, this.root.orthogonalSize, this.root.size, this.locked, this.margin);\n    if (oldRoot.children.length === 0) {\n      // no data so no need to add anything back in\n    } else if (oldRoot.children.length === 1) {\n      // can remove one level of redundant branching if there is only a single child\n      const childReference = oldRoot.children[0];\n      const child = oldRoot.removeChild(0); // remove to prevent disposal when disposing of unwanted root\n      child.dispose();\n      oldRoot.dispose();\n      this._root.addChild(\n      /**\n       * the child node will have the same orientation as the new root since\n       * we are removing the inbetween node.\n       * the entire 'tree' must be flipped recursively to ensure that the orientation\n       * flips at each level\n       */\n      flipNode(childReference, childReference.orthogonalSize, childReference.size), Sizing.Distribute, 0);\n    } else {\n      this._root.addChild(oldRoot, Sizing.Distribute, 0);\n    }\n    this.element.appendChild(this._root.element);\n    this.disposable.value = this._root.onDidChange(e => {\n      this._onDidChange.fire(e);\n    });\n  }\n  next(location) {\n    return this.progmaticSelect(location);\n  }\n  previous(location) {\n    return this.progmaticSelect(location, true);\n  }\n  getView(location) {\n    const node = location ? this.getNode(location)[1] : this.root;\n    return this._getViews(node, this.orientation);\n  }\n  _getViews(node, orientation, cachedVisibleSize) {\n    const box = {\n      height: node.height,\n      width: node.width\n    };\n    if (node instanceof LeafNode) {\n      return {\n        box,\n        view: node.view,\n        cachedVisibleSize\n      };\n    }\n    const children = [];\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      const nodeCachedVisibleSize = node.getChildCachedVisibleSize(i);\n      children.push(this._getViews(child, orthogonal(orientation), nodeCachedVisibleSize));\n    }\n    return {\n      box,\n      children\n    };\n  }\n  progmaticSelect(location, reverse = false) {\n    const [path, node] = this.getNode(location);\n    if (!(node instanceof LeafNode)) {\n      throw new Error('invalid location');\n    }\n    for (let i = path.length - 1; i > -1; i--) {\n      const n = path[i];\n      const l = location[i] || 0;\n      const canProgressInCurrentLevel = reverse ? l - 1 > -1 : l + 1 < n.children.length;\n      if (canProgressInCurrentLevel) {\n        return findLeaf(n.children[reverse ? l - 1 : l + 1], reverse);\n      }\n    }\n    return findLeaf(this.root, reverse);\n  }\n  constructor(proportionalLayout, styles, orientation, locked, margin) {\n    this.proportionalLayout = proportionalLayout;\n    this.styles = styles;\n    this._locked = false;\n    this._margin = 0;\n    this._maximizedNode = undefined;\n    this.disposable = new MutableDisposable();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n    this._onDidViewVisibilityChange = new Emitter();\n    this.onDidViewVisibilityChange = this._onDidViewVisibilityChange.event;\n    this._onDidMaximizedNodeChange = new Emitter();\n    this.onDidMaximizedNodeChange = this._onDidMaximizedNodeChange.event;\n    this.element = document.createElement('div');\n    this.element.className = 'dv-grid-view';\n    this._locked = locked !== null && locked !== void 0 ? locked : false;\n    this._margin = margin !== null && margin !== void 0 ? margin : 0;\n    this.root = new BranchNode(orientation, proportionalLayout, styles, 0, 0, this.locked, this.margin);\n  }\n  isViewVisible(location) {\n    const [rest, index] = tail(location);\n    const [, parent] = this.getNode(rest);\n    if (!(parent instanceof BranchNode)) {\n      throw new Error('Invalid from location');\n    }\n    return parent.isChildVisible(index);\n  }\n  setViewVisible(location, visible) {\n    if (this.hasMaximizedView()) {\n      this.exitMaximizedView();\n    }\n    const [rest, index] = tail(location);\n    const [, parent] = this.getNode(rest);\n    if (!(parent instanceof BranchNode)) {\n      throw new Error('Invalid from location');\n    }\n    this._onDidViewVisibilityChange.fire();\n    parent.setChildVisible(index, visible);\n  }\n  moveView(parentLocation, from, to) {\n    if (this.hasMaximizedView()) {\n      this.exitMaximizedView();\n    }\n    const [, parent] = this.getNode(parentLocation);\n    if (!(parent instanceof BranchNode)) {\n      throw new Error('Invalid location');\n    }\n    parent.moveChild(from, to);\n  }\n  addView(view, size, location) {\n    if (this.hasMaximizedView()) {\n      this.exitMaximizedView();\n    }\n    const [rest, index] = tail(location);\n    const [pathToParent, parent] = this.getNode(rest);\n    if (parent instanceof BranchNode) {\n      const node = new LeafNode(view, orthogonal(parent.orientation), parent.orthogonalSize);\n      parent.addChild(node, size, index);\n    } else {\n      const [grandParent, ..._] = [...pathToParent].reverse();\n      const [parentIndex, ...__] = [...rest].reverse();\n      let newSiblingSize = 0;\n      const newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);\n      if (typeof newSiblingCachedVisibleSize === 'number') {\n        newSiblingSize = Sizing.Invisible(newSiblingCachedVisibleSize);\n      }\n      const child = grandParent.removeChild(parentIndex);\n      child.dispose();\n      const newParent = new BranchNode(parent.orientation, this.proportionalLayout, this.styles, parent.size, parent.orthogonalSize, this.locked, this.margin);\n      grandParent.addChild(newParent, parent.size, parentIndex);\n      const newSibling = new LeafNode(parent.view, grandParent.orientation, parent.size);\n      newParent.addChild(newSibling, newSiblingSize, 0);\n      if (typeof size !== 'number' && size.type === 'split') {\n        size = {\n          type: 'split',\n          index: 0\n        };\n      }\n      const node = new LeafNode(view, grandParent.orientation, parent.size);\n      newParent.addChild(node, size, index);\n    }\n  }\n  remove(view, sizing) {\n    const location = getGridLocation(view.element);\n    return this.removeView(location, sizing);\n  }\n  removeView(location, sizing) {\n    if (this.hasMaximizedView()) {\n      this.exitMaximizedView();\n    }\n    const [rest, index] = tail(location);\n    const [pathToParent, parent] = this.getNode(rest);\n    if (!(parent instanceof BranchNode)) {\n      throw new Error('Invalid location');\n    }\n    const nodeToRemove = parent.children[index];\n    if (!(nodeToRemove instanceof LeafNode)) {\n      throw new Error('Invalid location');\n    }\n    parent.removeChild(index, sizing);\n    nodeToRemove.dispose();\n    if (parent.children.length !== 1) {\n      return nodeToRemove.view;\n    }\n    // if the parent has only one child and we know the parent is a BranchNode we can make the tree\n    // more efficiently spaced by replacing the parent BranchNode with the child.\n    // if that child is a LeafNode then we simply replace the BranchNode with the child otherwise if the child\n    // is a BranchNode too we should spread it's children into the grandparent.\n    // refer to the remaining child as the sibling\n    const sibling = parent.children[0];\n    if (pathToParent.length === 0) {\n      // if the parent is root\n      if (sibling instanceof LeafNode) {\n        // if the sibling is a leaf node no action is required\n        return nodeToRemove.view;\n      }\n      // otherwise the sibling is a branch node. since the parent is the root and the root has only one child\n      // which is a branch node we can just set this branch node to be the new root node\n      // for good housekeeping we'll removing the sibling from it's existing tree\n      parent.removeChild(0, sizing);\n      // and set that sibling node to be root\n      this.root = sibling;\n      return nodeToRemove.view;\n    }\n    // otherwise the parent is apart of a large sub-tree\n    const [grandParent, ..._] = [...pathToParent].reverse();\n    const [parentIndex, ...__] = [...rest].reverse();\n    const isSiblingVisible = parent.isChildVisible(0);\n    // either way we need to remove the sibling from it's existing tree\n    parent.removeChild(0, sizing);\n    // note the sizes of all of the grandparents children\n    const sizes = grandParent.children.map((_size, i) => grandParent.getChildSize(i));\n    // remove the parent from the grandparent since we are moving the sibling to take the parents place\n    // this parent is no longer used and can be disposed of\n    grandParent.removeChild(parentIndex, sizing).dispose();\n    if (sibling instanceof BranchNode) {\n      // replace the parent with the siblings children\n      sizes.splice(parentIndex, 1, ...sibling.children.map(c => c.size));\n      // and add those siblings to the grandparent\n      for (let i = 0; i < sibling.children.length; i++) {\n        const child = sibling.children[i];\n        grandParent.addChild(child, child.size, parentIndex + i);\n      }\n      /**\n       * clean down the branch node since we need to dipose of it and\n       * when .dispose() it called on a branch it will dispose of any\n       * views it is holding onto.\n       */\n      while (sibling.children.length > 0) {\n        sibling.removeChild(0);\n      }\n    } else {\n      // otherwise create a new leaf node and add that to the grandparent\n      const newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), sibling.size);\n      const siblingSizing = isSiblingVisible ? sibling.orthogonalSize : Sizing.Invisible(sibling.orthogonalSize);\n      grandParent.addChild(newSibling, siblingSizing, parentIndex);\n    }\n    // the containing node of the sibling is no longer required and can be disposed of\n    sibling.dispose();\n    // resize everything\n    for (let i = 0; i < sizes.length; i++) {\n      grandParent.resizeChild(i, sizes[i]);\n    }\n    return nodeToRemove.view;\n  }\n  layout(width, height) {\n    const [size, orthogonalSize] = this.root.orientation === Orientation.HORIZONTAL ? [height, width] : [width, height];\n    this.root.layout(size, orthogonalSize);\n  }\n  getNode(location, node = this.root, path = []) {\n    if (location.length === 0) {\n      return [path, node];\n    }\n    if (!(node instanceof BranchNode)) {\n      throw new Error('Invalid location');\n    }\n    const [index, ...rest] = location;\n    if (index < 0 || index >= node.children.length) {\n      throw new Error('Invalid location');\n    }\n    const child = node.children[index];\n    path.push(node);\n    return this.getNode(rest, child, path);\n  }\n}","map":{"version":3,"names":["Orientation","Sizing","tail","LeafNode","BranchNode","Emitter","MutableDisposable","findLeaf","candiateNode","last","children","length","Error","flipNode","node","size","orthogonalSize","result","orthogonal","orientation","proportionalLayout","styles","disabled","margin","totalSize","i","child","childSize","newSize","Math","round","addChild","view","indexInParent","element","parentElement","el","firstElementChild","index","lastElementChild","nextElementSibling","getGridLocation","test","className","ancestor","getRelativeLocation","rootOrientation","location","direction","getLocationOrientation","directionOrientation","getDirectionOrientation","rest","_index","VERTICAL","HORIZONTAL","isGridBranchNode","serializeBranchNode","box","width","height","cachedVisibleSize","type","data","toJSON","visible","map","c","Gridview","_root","root","layout","minimumWidth","minimumHeight","maximumWidth","maximumHeight","locked","_locked","value","branch","pop","push","_margin","maximizedView","_a","_maximizedNode","leaf","hasMaximizedView","undefined","maximizeView","_","getNode","exitMaximizedView","getView","hiddenOnMaximize","hideAllViewsBut","parent","exclude","isChildVisible","setChildVisible","_onDidMaximizedNodeChange","fire","isMaximized","showViewsInReverseOrder","includes","tmp","serialize","maxmizedViewLocation","resullt","maximizedNode","dispose","disposable","_onDidChange","_onDidViewVisibilityChange","remove","clear","deserialize","json","deserializer","_deserialize","_deserializeNode","serializedChildren","serializedChild","fromJSON","setVisible","call","oldRoot","removeChild","appendChild","onDidChange","e","insertOrthogonalSplitviewAtRoot","childReference","Distribute","next","progmaticSelect","previous","_getViews","nodeCachedVisibleSize","getChildCachedVisibleSize","reverse","path","n","l","canProgressInCurrentLevel","constructor","event","onDidViewVisibilityChange","onDidMaximizedNodeChange","document","createElement","isViewVisible","setViewVisible","moveView","parentLocation","from","to","moveChild","addView","pathToParent","grandParent","parentIndex","__","newSiblingSize","newSiblingCachedVisibleSize","Invisible","newParent","newSibling","sizing","removeView","nodeToRemove","sibling","isSiblingVisible","sizes","_size","getChildSize","splice","siblingSizing","resizeChild"],"sources":["E:/dockview.demo/node_modules/dockview-core/dist/esm/gridview/gridview.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n * Accreditation: This file is largly based upon the MIT licenced VSCode sourcecode found at:\n * https://github.com/microsoft/vscode/tree/main/src/vs/base/browser/ui/grid\n *--------------------------------------------------------------------------------------------*/\nimport { Orientation, Sizing, } from '../splitview/splitview';\nimport { tail } from '../array';\nimport { LeafNode } from './leafNode';\nimport { BranchNode } from './branchNode';\nimport { Emitter } from '../events';\nimport { MutableDisposable } from '../lifecycle';\nfunction findLeaf(candiateNode, last) {\n    if (candiateNode instanceof LeafNode) {\n        return candiateNode;\n    }\n    if (candiateNode instanceof BranchNode) {\n        return findLeaf(candiateNode.children[last ? candiateNode.children.length - 1 : 0], last);\n    }\n    throw new Error('invalid node');\n}\nfunction flipNode(node, size, orthogonalSize) {\n    if (node instanceof BranchNode) {\n        const result = new BranchNode(orthogonal(node.orientation), node.proportionalLayout, node.styles, size, orthogonalSize, node.disabled, node.margin);\n        let totalSize = 0;\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            const child = node.children[i];\n            const childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;\n            let newSize = node.size === 0\n                ? 0\n                : Math.round((size * childSize) / node.size);\n            totalSize += newSize;\n            // The last view to add should adjust to rounding errors\n            if (i === 0) {\n                newSize += size - totalSize;\n            }\n            result.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);\n        }\n        return result;\n    }\n    else {\n        return new LeafNode(node.view, orthogonal(node.orientation), orthogonalSize);\n    }\n}\nexport function indexInParent(element) {\n    const parentElement = element.parentElement;\n    if (!parentElement) {\n        throw new Error('Invalid grid element');\n    }\n    let el = parentElement.firstElementChild;\n    let index = 0;\n    while (el !== element && el !== parentElement.lastElementChild && el) {\n        el = el.nextElementSibling;\n        index++;\n    }\n    return index;\n}\n/**\n * Find the grid location of a specific DOM element by traversing the parent\n * chain and finding each child index on the way.\n *\n * This will break as soon as DOM structures of the Splitview or Gridview change.\n */\nexport function getGridLocation(element) {\n    const parentElement = element.parentElement;\n    if (!parentElement) {\n        throw new Error('Invalid grid element');\n    }\n    if (/\\bdv-grid-view\\b/.test(parentElement.className)) {\n        return [];\n    }\n    const index = indexInParent(parentElement);\n    const ancestor = parentElement.parentElement.parentElement.parentElement;\n    return [...getGridLocation(ancestor), index];\n}\nexport function getRelativeLocation(rootOrientation, location, direction) {\n    const orientation = getLocationOrientation(rootOrientation, location);\n    const directionOrientation = getDirectionOrientation(direction);\n    if (orientation === directionOrientation) {\n        const [rest, _index] = tail(location);\n        let index = _index;\n        if (direction === 'right' || direction === 'bottom') {\n            index += 1;\n        }\n        return [...rest, index];\n    }\n    else {\n        const index = direction === 'right' || direction === 'bottom' ? 1 : 0;\n        return [...location, index];\n    }\n}\nexport function getDirectionOrientation(direction) {\n    return direction === 'top' || direction === 'bottom'\n        ? Orientation.VERTICAL\n        : Orientation.HORIZONTAL;\n}\nexport function getLocationOrientation(rootOrientation, location) {\n    return location.length % 2 === 0\n        ? orthogonal(rootOrientation)\n        : rootOrientation;\n}\nexport const orthogonal = (orientation) => orientation === Orientation.HORIZONTAL\n    ? Orientation.VERTICAL\n    : Orientation.HORIZONTAL;\nexport function isGridBranchNode(node) {\n    return !!node.children;\n}\nconst serializeBranchNode = (node, orientation) => {\n    const size = orientation === Orientation.VERTICAL ? node.box.width : node.box.height;\n    if (!isGridBranchNode(node)) {\n        if (typeof node.cachedVisibleSize === 'number') {\n            return {\n                type: 'leaf',\n                data: node.view.toJSON(),\n                size: node.cachedVisibleSize,\n                visible: false,\n            };\n        }\n        return { type: 'leaf', data: node.view.toJSON(), size };\n    }\n    return {\n        type: 'branch',\n        data: node.children.map((c) => serializeBranchNode(c, orthogonal(orientation))),\n        size,\n    };\n};\nexport class Gridview {\n    get length() {\n        return this._root ? this._root.children.length : 0;\n    }\n    get orientation() {\n        return this.root.orientation;\n    }\n    set orientation(orientation) {\n        if (this.root.orientation === orientation) {\n            return;\n        }\n        const { size, orthogonalSize } = this.root;\n        this.root = flipNode(this.root, orthogonalSize, size);\n        this.root.layout(size, orthogonalSize);\n    }\n    get width() {\n        return this.root.width;\n    }\n    get height() {\n        return this.root.height;\n    }\n    get minimumWidth() {\n        return this.root.minimumWidth;\n    }\n    get minimumHeight() {\n        return this.root.minimumHeight;\n    }\n    get maximumWidth() {\n        return this.root.maximumHeight;\n    }\n    get maximumHeight() {\n        return this.root.maximumHeight;\n    }\n    get locked() {\n        return this._locked;\n    }\n    set locked(value) {\n        this._locked = value;\n        const branch = [this.root];\n        /**\n         * simple depth-first-search to cover all nodes\n         *\n         * @see https://en.wikipedia.org/wiki/Depth-first_search\n         */\n        while (branch.length > 0) {\n            const node = branch.pop();\n            if (node instanceof BranchNode) {\n                node.disabled = value;\n                branch.push(...node.children);\n            }\n        }\n    }\n    get margin() {\n        return this._margin;\n    }\n    set margin(value) {\n        this._margin = value;\n        this.root.margin = value;\n    }\n    maximizedView() {\n        var _a;\n        return (_a = this._maximizedNode) === null || _a === void 0 ? void 0 : _a.leaf.view;\n    }\n    hasMaximizedView() {\n        return this._maximizedNode !== undefined;\n    }\n    maximizeView(view) {\n        var _a;\n        const location = getGridLocation(view.element);\n        const [_, node] = this.getNode(location);\n        if (!(node instanceof LeafNode)) {\n            return;\n        }\n        if (((_a = this._maximizedNode) === null || _a === void 0 ? void 0 : _a.leaf) === node) {\n            return;\n        }\n        if (this.hasMaximizedView()) {\n            this.exitMaximizedView();\n        }\n        serializeBranchNode(this.getView(), this.orientation);\n        const hiddenOnMaximize = [];\n        function hideAllViewsBut(parent, exclude) {\n            for (let i = 0; i < parent.children.length; i++) {\n                const child = parent.children[i];\n                if (child instanceof LeafNode) {\n                    if (child !== exclude) {\n                        if (parent.isChildVisible(i)) {\n                            parent.setChildVisible(i, false);\n                        }\n                        else {\n                            hiddenOnMaximize.push(child);\n                        }\n                    }\n                }\n                else {\n                    hideAllViewsBut(child, exclude);\n                }\n            }\n        }\n        hideAllViewsBut(this.root, node);\n        this._maximizedNode = { leaf: node, hiddenOnMaximize };\n        this._onDidMaximizedNodeChange.fire({\n            view: node.view,\n            isMaximized: true,\n        });\n    }\n    exitMaximizedView() {\n        if (!this._maximizedNode) {\n            return;\n        }\n        const hiddenOnMaximize = this._maximizedNode.hiddenOnMaximize;\n        function showViewsInReverseOrder(parent) {\n            for (let index = parent.children.length - 1; index >= 0; index--) {\n                const child = parent.children[index];\n                if (child instanceof LeafNode) {\n                    if (!hiddenOnMaximize.includes(child)) {\n                        parent.setChildVisible(index, true);\n                    }\n                }\n                else {\n                    showViewsInReverseOrder(child);\n                }\n            }\n        }\n        showViewsInReverseOrder(this.root);\n        const tmp = this._maximizedNode.leaf;\n        this._maximizedNode = undefined;\n        this._onDidMaximizedNodeChange.fire({\n            view: tmp.view,\n            isMaximized: false,\n        });\n    }\n    serialize() {\n        const maximizedView = this.maximizedView();\n        let maxmizedViewLocation;\n        if (maximizedView) {\n            /**\n             * The minimum information we can get away with in order to serialize a maxmized view is it's location within the grid\n             * which is represented as a branch of indices\n             */\n            maxmizedViewLocation = getGridLocation(maximizedView.element);\n        }\n        if (this.hasMaximizedView()) {\n            /**\n             * the saved layout cannot be in its maxmized state otherwise all of the underlying\n             * view dimensions will be wrong\n             *\n             * To counteract this we temporaily remove the maximized view to compute the serialized output\n             * of the grid before adding back the maxmized view as to not alter the layout from the users\n             * perspective when `.toJSON()` is called\n             */\n            this.exitMaximizedView();\n        }\n        const root = serializeBranchNode(this.getView(), this.orientation);\n        const resullt = {\n            root,\n            width: this.width,\n            height: this.height,\n            orientation: this.orientation,\n        };\n        if (maxmizedViewLocation) {\n            resullt.maximizedNode = {\n                location: maxmizedViewLocation,\n            };\n        }\n        if (maximizedView) {\n            // replace any maximzied view that was removed for serialization purposes\n            this.maximizeView(maximizedView);\n        }\n        return resullt;\n    }\n    dispose() {\n        this.disposable.dispose();\n        this._onDidChange.dispose();\n        this._onDidMaximizedNodeChange.dispose();\n        this._onDidViewVisibilityChange.dispose();\n        this.root.dispose();\n        this._maximizedNode = undefined;\n        this.element.remove();\n    }\n    clear() {\n        const orientation = this.root.orientation;\n        this.root = new BranchNode(orientation, this.proportionalLayout, this.styles, this.root.size, this.root.orthogonalSize, this.locked, this.margin);\n    }\n    deserialize(json, deserializer) {\n        const orientation = json.orientation;\n        const height = orientation === Orientation.VERTICAL ? json.height : json.width;\n        this._deserialize(json.root, orientation, deserializer, height);\n        /**\n         * The deserialied layout must be positioned through this.layout(...)\n         * before any maximizedNode can be positioned\n         */\n        this.layout(json.width, json.height);\n        if (json.maximizedNode) {\n            const location = json.maximizedNode.location;\n            const [_, node] = this.getNode(location);\n            if (!(node instanceof LeafNode)) {\n                return;\n            }\n            this.maximizeView(node.view);\n        }\n    }\n    _deserialize(root, orientation, deserializer, orthogonalSize) {\n        this.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize);\n    }\n    _deserializeNode(node, orientation, deserializer, orthogonalSize) {\n        var _a;\n        let result;\n        if (node.type === 'branch') {\n            const serializedChildren = node.data;\n            const children = serializedChildren.map((serializedChild) => {\n                return {\n                    node: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),\n                    visible: serializedChild.visible,\n                };\n            });\n            result = new BranchNode(orientation, this.proportionalLayout, this.styles, node.size, // <- orthogonal size - flips at each depth\n            orthogonalSize, // <- size - flips at each depth,\n            this.locked, this.margin, children);\n        }\n        else {\n            const view = deserializer.fromJSON(node);\n            if (typeof node.visible === 'boolean') {\n                (_a = view.setVisible) === null || _a === void 0 ? void 0 : _a.call(view, node.visible);\n            }\n            result = new LeafNode(view, orientation, orthogonalSize, node.size);\n        }\n        return result;\n    }\n    get root() {\n        return this._root;\n    }\n    set root(root) {\n        const oldRoot = this._root;\n        if (oldRoot) {\n            oldRoot.dispose();\n            this._maximizedNode = undefined;\n            this.element.removeChild(oldRoot.element);\n        }\n        this._root = root;\n        this.element.appendChild(this._root.element);\n        this.disposable.value = this._root.onDidChange((e) => {\n            this._onDidChange.fire(e);\n        });\n    }\n    /**\n     * If the root is orientated as a VERTICAL node then nest the existing root within a new HORIZIONTAL root node\n     * If the root is orientated as a HORIZONTAL node then nest the existing root within a new VERITCAL root node\n     */\n    insertOrthogonalSplitviewAtRoot() {\n        if (!this._root) {\n            return;\n        }\n        const oldRoot = this.root;\n        oldRoot.element.remove();\n        this._root = new BranchNode(orthogonal(oldRoot.orientation), this.proportionalLayout, this.styles, this.root.orthogonalSize, this.root.size, this.locked, this.margin);\n        if (oldRoot.children.length === 0) {\n            // no data so no need to add anything back in\n        }\n        else if (oldRoot.children.length === 1) {\n            // can remove one level of redundant branching if there is only a single child\n            const childReference = oldRoot.children[0];\n            const child = oldRoot.removeChild(0); // remove to prevent disposal when disposing of unwanted root\n            child.dispose();\n            oldRoot.dispose();\n            this._root.addChild(\n            /**\n             * the child node will have the same orientation as the new root since\n             * we are removing the inbetween node.\n             * the entire 'tree' must be flipped recursively to ensure that the orientation\n             * flips at each level\n             */\n            flipNode(childReference, childReference.orthogonalSize, childReference.size), Sizing.Distribute, 0);\n        }\n        else {\n            this._root.addChild(oldRoot, Sizing.Distribute, 0);\n        }\n        this.element.appendChild(this._root.element);\n        this.disposable.value = this._root.onDidChange((e) => {\n            this._onDidChange.fire(e);\n        });\n    }\n    next(location) {\n        return this.progmaticSelect(location);\n    }\n    previous(location) {\n        return this.progmaticSelect(location, true);\n    }\n    getView(location) {\n        const node = location ? this.getNode(location)[1] : this.root;\n        return this._getViews(node, this.orientation);\n    }\n    _getViews(node, orientation, cachedVisibleSize) {\n        const box = { height: node.height, width: node.width };\n        if (node instanceof LeafNode) {\n            return { box, view: node.view, cachedVisibleSize };\n        }\n        const children = [];\n        for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            const nodeCachedVisibleSize = node.getChildCachedVisibleSize(i);\n            children.push(this._getViews(child, orthogonal(orientation), nodeCachedVisibleSize));\n        }\n        return { box, children };\n    }\n    progmaticSelect(location, reverse = false) {\n        const [path, node] = this.getNode(location);\n        if (!(node instanceof LeafNode)) {\n            throw new Error('invalid location');\n        }\n        for (let i = path.length - 1; i > -1; i--) {\n            const n = path[i];\n            const l = location[i] || 0;\n            const canProgressInCurrentLevel = reverse\n                ? l - 1 > -1\n                : l + 1 < n.children.length;\n            if (canProgressInCurrentLevel) {\n                return findLeaf(n.children[reverse ? l - 1 : l + 1], reverse);\n            }\n        }\n        return findLeaf(this.root, reverse);\n    }\n    constructor(proportionalLayout, styles, orientation, locked, margin) {\n        this.proportionalLayout = proportionalLayout;\n        this.styles = styles;\n        this._locked = false;\n        this._margin = 0;\n        this._maximizedNode = undefined;\n        this.disposable = new MutableDisposable();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._onDidViewVisibilityChange = new Emitter();\n        this.onDidViewVisibilityChange = this._onDidViewVisibilityChange.event;\n        this._onDidMaximizedNodeChange = new Emitter();\n        this.onDidMaximizedNodeChange = this._onDidMaximizedNodeChange.event;\n        this.element = document.createElement('div');\n        this.element.className = 'dv-grid-view';\n        this._locked = locked !== null && locked !== void 0 ? locked : false;\n        this._margin = margin !== null && margin !== void 0 ? margin : 0;\n        this.root = new BranchNode(orientation, proportionalLayout, styles, 0, 0, this.locked, this.margin);\n    }\n    isViewVisible(location) {\n        const [rest, index] = tail(location);\n        const [, parent] = this.getNode(rest);\n        if (!(parent instanceof BranchNode)) {\n            throw new Error('Invalid from location');\n        }\n        return parent.isChildVisible(index);\n    }\n    setViewVisible(location, visible) {\n        if (this.hasMaximizedView()) {\n            this.exitMaximizedView();\n        }\n        const [rest, index] = tail(location);\n        const [, parent] = this.getNode(rest);\n        if (!(parent instanceof BranchNode)) {\n            throw new Error('Invalid from location');\n        }\n        this._onDidViewVisibilityChange.fire();\n        parent.setChildVisible(index, visible);\n    }\n    moveView(parentLocation, from, to) {\n        if (this.hasMaximizedView()) {\n            this.exitMaximizedView();\n        }\n        const [, parent] = this.getNode(parentLocation);\n        if (!(parent instanceof BranchNode)) {\n            throw new Error('Invalid location');\n        }\n        parent.moveChild(from, to);\n    }\n    addView(view, size, location) {\n        if (this.hasMaximizedView()) {\n            this.exitMaximizedView();\n        }\n        const [rest, index] = tail(location);\n        const [pathToParent, parent] = this.getNode(rest);\n        if (parent instanceof BranchNode) {\n            const node = new LeafNode(view, orthogonal(parent.orientation), parent.orthogonalSize);\n            parent.addChild(node, size, index);\n        }\n        else {\n            const [grandParent, ..._] = [...pathToParent].reverse();\n            const [parentIndex, ...__] = [...rest].reverse();\n            let newSiblingSize = 0;\n            const newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);\n            if (typeof newSiblingCachedVisibleSize === 'number') {\n                newSiblingSize = Sizing.Invisible(newSiblingCachedVisibleSize);\n            }\n            const child = grandParent.removeChild(parentIndex);\n            child.dispose();\n            const newParent = new BranchNode(parent.orientation, this.proportionalLayout, this.styles, parent.size, parent.orthogonalSize, this.locked, this.margin);\n            grandParent.addChild(newParent, parent.size, parentIndex);\n            const newSibling = new LeafNode(parent.view, grandParent.orientation, parent.size);\n            newParent.addChild(newSibling, newSiblingSize, 0);\n            if (typeof size !== 'number' && size.type === 'split') {\n                size = { type: 'split', index: 0 };\n            }\n            const node = new LeafNode(view, grandParent.orientation, parent.size);\n            newParent.addChild(node, size, index);\n        }\n    }\n    remove(view, sizing) {\n        const location = getGridLocation(view.element);\n        return this.removeView(location, sizing);\n    }\n    removeView(location, sizing) {\n        if (this.hasMaximizedView()) {\n            this.exitMaximizedView();\n        }\n        const [rest, index] = tail(location);\n        const [pathToParent, parent] = this.getNode(rest);\n        if (!(parent instanceof BranchNode)) {\n            throw new Error('Invalid location');\n        }\n        const nodeToRemove = parent.children[index];\n        if (!(nodeToRemove instanceof LeafNode)) {\n            throw new Error('Invalid location');\n        }\n        parent.removeChild(index, sizing);\n        nodeToRemove.dispose();\n        if (parent.children.length !== 1) {\n            return nodeToRemove.view;\n        }\n        // if the parent has only one child and we know the parent is a BranchNode we can make the tree\n        // more efficiently spaced by replacing the parent BranchNode with the child.\n        // if that child is a LeafNode then we simply replace the BranchNode with the child otherwise if the child\n        // is a BranchNode too we should spread it's children into the grandparent.\n        // refer to the remaining child as the sibling\n        const sibling = parent.children[0];\n        if (pathToParent.length === 0) {\n            // if the parent is root\n            if (sibling instanceof LeafNode) {\n                // if the sibling is a leaf node no action is required\n                return nodeToRemove.view;\n            }\n            // otherwise the sibling is a branch node. since the parent is the root and the root has only one child\n            // which is a branch node we can just set this branch node to be the new root node\n            // for good housekeeping we'll removing the sibling from it's existing tree\n            parent.removeChild(0, sizing);\n            // and set that sibling node to be root\n            this.root = sibling;\n            return nodeToRemove.view;\n        }\n        // otherwise the parent is apart of a large sub-tree\n        const [grandParent, ..._] = [...pathToParent].reverse();\n        const [parentIndex, ...__] = [...rest].reverse();\n        const isSiblingVisible = parent.isChildVisible(0);\n        // either way we need to remove the sibling from it's existing tree\n        parent.removeChild(0, sizing);\n        // note the sizes of all of the grandparents children\n        const sizes = grandParent.children.map((_size, i) => grandParent.getChildSize(i));\n        // remove the parent from the grandparent since we are moving the sibling to take the parents place\n        // this parent is no longer used and can be disposed of\n        grandParent.removeChild(parentIndex, sizing).dispose();\n        if (sibling instanceof BranchNode) {\n            // replace the parent with the siblings children\n            sizes.splice(parentIndex, 1, ...sibling.children.map((c) => c.size));\n            // and add those siblings to the grandparent\n            for (let i = 0; i < sibling.children.length; i++) {\n                const child = sibling.children[i];\n                grandParent.addChild(child, child.size, parentIndex + i);\n            }\n            /**\n             * clean down the branch node since we need to dipose of it and\n             * when .dispose() it called on a branch it will dispose of any\n             * views it is holding onto.\n             */\n            while (sibling.children.length > 0) {\n                sibling.removeChild(0);\n            }\n        }\n        else {\n            // otherwise create a new leaf node and add that to the grandparent\n            const newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), sibling.size);\n            const siblingSizing = isSiblingVisible\n                ? sibling.orthogonalSize\n                : Sizing.Invisible(sibling.orthogonalSize);\n            grandParent.addChild(newSibling, siblingSizing, parentIndex);\n        }\n        // the containing node of the sibling is no longer required and can be disposed of\n        sibling.dispose();\n        // resize everything\n        for (let i = 0; i < sizes.length; i++) {\n            grandParent.resizeChild(i, sizes[i]);\n        }\n        return nodeToRemove.view;\n    }\n    layout(width, height) {\n        const [size, orthogonalSize] = this.root.orientation === Orientation.HORIZONTAL\n            ? [height, width]\n            : [width, height];\n        this.root.layout(size, orthogonalSize);\n    }\n    getNode(location, node = this.root, path = []) {\n        if (location.length === 0) {\n            return [path, node];\n        }\n        if (!(node instanceof BranchNode)) {\n            throw new Error('Invalid location');\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index >= node.children.length) {\n            throw new Error('Invalid location');\n        }\n        const child = node.children[index];\n        path.push(node);\n        return this.getNode(rest, child, path);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,MAAM,QAAS,wBAAwB;AAC7D,SAASC,IAAI,QAAQ,UAAU;AAC/B,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,OAAO,QAAQ,WAAW;AACnC,SAASC,iBAAiB,QAAQ,cAAc;AAChD,SAASC,QAAQA,CAACC,YAAY,EAAEC,IAAI,EAAE;EAClC,IAAID,YAAY,YAAYL,QAAQ,EAAE;IAClC,OAAOK,YAAY;EACvB;EACA,IAAIA,YAAY,YAAYJ,UAAU,EAAE;IACpC,OAAOG,QAAQ,CAACC,YAAY,CAACE,QAAQ,CAACD,IAAI,GAAGD,YAAY,CAACE,QAAQ,CAACC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEF,IAAI,CAAC;EAC7F;EACA,MAAM,IAAIG,KAAK,CAAC,cAAc,CAAC;AACnC;AACA,SAASC,QAAQA,CAACC,IAAI,EAAEC,IAAI,EAAEC,cAAc,EAAE;EAC1C,IAAIF,IAAI,YAAYV,UAAU,EAAE;IAC5B,MAAMa,MAAM,GAAG,IAAIb,UAAU,CAACc,UAAU,CAACJ,IAAI,CAACK,WAAW,CAAC,EAAEL,IAAI,CAACM,kBAAkB,EAAEN,IAAI,CAACO,MAAM,EAAEN,IAAI,EAAEC,cAAc,EAAEF,IAAI,CAACQ,QAAQ,EAAER,IAAI,CAACS,MAAM,CAAC;IACnJ,IAAIC,SAAS,GAAG,CAAC;IACjB,KAAK,IAAIC,CAAC,GAAGX,IAAI,CAACJ,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAChD,MAAMC,KAAK,GAAGZ,IAAI,CAACJ,QAAQ,CAACe,CAAC,CAAC;MAC9B,MAAME,SAAS,GAAGD,KAAK,YAAYtB,UAAU,GAAGsB,KAAK,CAACV,cAAc,GAAGU,KAAK,CAACX,IAAI;MACjF,IAAIa,OAAO,GAAGd,IAAI,CAACC,IAAI,KAAK,CAAC,GACvB,CAAC,GACDc,IAAI,CAACC,KAAK,CAAEf,IAAI,GAAGY,SAAS,GAAIb,IAAI,CAACC,IAAI,CAAC;MAChDS,SAAS,IAAII,OAAO;MACpB;MACA,IAAIH,CAAC,KAAK,CAAC,EAAE;QACTG,OAAO,IAAIb,IAAI,GAAGS,SAAS;MAC/B;MACAP,MAAM,CAACc,QAAQ,CAAClB,QAAQ,CAACa,KAAK,EAAEV,cAAc,EAAEY,OAAO,CAAC,EAAEA,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC;IAC/E;IACA,OAAOX,MAAM;EACjB,CAAC,MACI;IACD,OAAO,IAAId,QAAQ,CAACW,IAAI,CAACkB,IAAI,EAAEd,UAAU,CAACJ,IAAI,CAACK,WAAW,CAAC,EAAEH,cAAc,CAAC;EAChF;AACJ;AACA,OAAO,SAASiB,aAAaA,CAACC,OAAO,EAAE;EACnC,MAAMC,aAAa,GAAGD,OAAO,CAACC,aAAa;EAC3C,IAAI,CAACA,aAAa,EAAE;IAChB,MAAM,IAAIvB,KAAK,CAAC,sBAAsB,CAAC;EAC3C;EACA,IAAIwB,EAAE,GAAGD,aAAa,CAACE,iBAAiB;EACxC,IAAIC,KAAK,GAAG,CAAC;EACb,OAAOF,EAAE,KAAKF,OAAO,IAAIE,EAAE,KAAKD,aAAa,CAACI,gBAAgB,IAAIH,EAAE,EAAE;IAClEA,EAAE,GAAGA,EAAE,CAACI,kBAAkB;IAC1BF,KAAK,EAAE;EACX;EACA,OAAOA,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,eAAeA,CAACP,OAAO,EAAE;EACrC,MAAMC,aAAa,GAAGD,OAAO,CAACC,aAAa;EAC3C,IAAI,CAACA,aAAa,EAAE;IAChB,MAAM,IAAIvB,KAAK,CAAC,sBAAsB,CAAC;EAC3C;EACA,IAAI,kBAAkB,CAAC8B,IAAI,CAACP,aAAa,CAACQ,SAAS,CAAC,EAAE;IAClD,OAAO,EAAE;EACb;EACA,MAAML,KAAK,GAAGL,aAAa,CAACE,aAAa,CAAC;EAC1C,MAAMS,QAAQ,GAAGT,aAAa,CAACA,aAAa,CAACA,aAAa,CAACA,aAAa;EACxE,OAAO,CAAC,GAAGM,eAAe,CAACG,QAAQ,CAAC,EAAEN,KAAK,CAAC;AAChD;AACA,OAAO,SAASO,mBAAmBA,CAACC,eAAe,EAAEC,QAAQ,EAAEC,SAAS,EAAE;EACtE,MAAM7B,WAAW,GAAG8B,sBAAsB,CAACH,eAAe,EAAEC,QAAQ,CAAC;EACrE,MAAMG,oBAAoB,GAAGC,uBAAuB,CAACH,SAAS,CAAC;EAC/D,IAAI7B,WAAW,KAAK+B,oBAAoB,EAAE;IACtC,MAAM,CAACE,IAAI,EAAEC,MAAM,CAAC,GAAGnD,IAAI,CAAC6C,QAAQ,CAAC;IACrC,IAAIT,KAAK,GAAGe,MAAM;IAClB,IAAIL,SAAS,KAAK,OAAO,IAAIA,SAAS,KAAK,QAAQ,EAAE;MACjDV,KAAK,IAAI,CAAC;IACd;IACA,OAAO,CAAC,GAAGc,IAAI,EAAEd,KAAK,CAAC;EAC3B,CAAC,MACI;IACD,MAAMA,KAAK,GAAGU,SAAS,KAAK,OAAO,IAAIA,SAAS,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC;IACrE,OAAO,CAAC,GAAGD,QAAQ,EAAET,KAAK,CAAC;EAC/B;AACJ;AACA,OAAO,SAASa,uBAAuBA,CAACH,SAAS,EAAE;EAC/C,OAAOA,SAAS,KAAK,KAAK,IAAIA,SAAS,KAAK,QAAQ,GAC9ChD,WAAW,CAACsD,QAAQ,GACpBtD,WAAW,CAACuD,UAAU;AAChC;AACA,OAAO,SAASN,sBAAsBA,CAACH,eAAe,EAAEC,QAAQ,EAAE;EAC9D,OAAOA,QAAQ,CAACpC,MAAM,GAAG,CAAC,KAAK,CAAC,GAC1BO,UAAU,CAAC4B,eAAe,CAAC,GAC3BA,eAAe;AACzB;AACA,OAAO,MAAM5B,UAAU,GAAIC,WAAW,IAAKA,WAAW,KAAKnB,WAAW,CAACuD,UAAU,GAC3EvD,WAAW,CAACsD,QAAQ,GACpBtD,WAAW,CAACuD,UAAU;AAC5B,OAAO,SAASC,gBAAgBA,CAAC1C,IAAI,EAAE;EACnC,OAAO,CAAC,CAACA,IAAI,CAACJ,QAAQ;AAC1B;AACA,MAAM+C,mBAAmB,GAAGA,CAAC3C,IAAI,EAAEK,WAAW,KAAK;EAC/C,MAAMJ,IAAI,GAAGI,WAAW,KAAKnB,WAAW,CAACsD,QAAQ,GAAGxC,IAAI,CAAC4C,GAAG,CAACC,KAAK,GAAG7C,IAAI,CAAC4C,GAAG,CAACE,MAAM;EACpF,IAAI,CAACJ,gBAAgB,CAAC1C,IAAI,CAAC,EAAE;IACzB,IAAI,OAAOA,IAAI,CAAC+C,iBAAiB,KAAK,QAAQ,EAAE;MAC5C,OAAO;QACHC,IAAI,EAAE,MAAM;QACZC,IAAI,EAAEjD,IAAI,CAACkB,IAAI,CAACgC,MAAM,CAAC,CAAC;QACxBjD,IAAI,EAAED,IAAI,CAAC+C,iBAAiB;QAC5BI,OAAO,EAAE;MACb,CAAC;IACL;IACA,OAAO;MAAEH,IAAI,EAAE,MAAM;MAAEC,IAAI,EAAEjD,IAAI,CAACkB,IAAI,CAACgC,MAAM,CAAC,CAAC;MAAEjD;IAAK,CAAC;EAC3D;EACA,OAAO;IACH+C,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAEjD,IAAI,CAACJ,QAAQ,CAACwD,GAAG,CAAEC,CAAC,IAAKV,mBAAmB,CAACU,CAAC,EAAEjD,UAAU,CAACC,WAAW,CAAC,CAAC,CAAC;IAC/EJ;EACJ,CAAC;AACL,CAAC;AACD,OAAO,MAAMqD,QAAQ,CAAC;EAClB,IAAIzD,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC0D,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC3D,QAAQ,CAACC,MAAM,GAAG,CAAC;EACtD;EACA,IAAIQ,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAACmD,IAAI,CAACnD,WAAW;EAChC;EACA,IAAIA,WAAWA,CAACA,WAAW,EAAE;IACzB,IAAI,IAAI,CAACmD,IAAI,CAACnD,WAAW,KAAKA,WAAW,EAAE;MACvC;IACJ;IACA,MAAM;MAAEJ,IAAI;MAAEC;IAAe,CAAC,GAAG,IAAI,CAACsD,IAAI;IAC1C,IAAI,CAACA,IAAI,GAAGzD,QAAQ,CAAC,IAAI,CAACyD,IAAI,EAAEtD,cAAc,EAAED,IAAI,CAAC;IACrD,IAAI,CAACuD,IAAI,CAACC,MAAM,CAACxD,IAAI,EAAEC,cAAc,CAAC;EAC1C;EACA,IAAI2C,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACW,IAAI,CAACX,KAAK;EAC1B;EACA,IAAIC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACU,IAAI,CAACV,MAAM;EAC3B;EACA,IAAIY,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACF,IAAI,CAACE,YAAY;EACjC;EACA,IAAIC,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACH,IAAI,CAACG,aAAa;EAClC;EACA,IAAIC,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACJ,IAAI,CAACK,aAAa;EAClC;EACA,IAAIA,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACL,IAAI,CAACK,aAAa;EAClC;EACA,IAAIC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,OAAO;EACvB;EACA,IAAID,MAAMA,CAACE,KAAK,EAAE;IACd,IAAI,CAACD,OAAO,GAAGC,KAAK;IACpB,MAAMC,MAAM,GAAG,CAAC,IAAI,CAACT,IAAI,CAAC;IAC1B;AACR;AACA;AACA;AACA;IACQ,OAAOS,MAAM,CAACpE,MAAM,GAAG,CAAC,EAAE;MACtB,MAAMG,IAAI,GAAGiE,MAAM,CAACC,GAAG,CAAC,CAAC;MACzB,IAAIlE,IAAI,YAAYV,UAAU,EAAE;QAC5BU,IAAI,CAACQ,QAAQ,GAAGwD,KAAK;QACrBC,MAAM,CAACE,IAAI,CAAC,GAAGnE,IAAI,CAACJ,QAAQ,CAAC;MACjC;IACJ;EACJ;EACA,IAAIa,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC2D,OAAO;EACvB;EACA,IAAI3D,MAAMA,CAACuD,KAAK,EAAE;IACd,IAAI,CAACI,OAAO,GAAGJ,KAAK;IACpB,IAAI,CAACR,IAAI,CAAC/C,MAAM,GAAGuD,KAAK;EAC5B;EACAK,aAAaA,CAAA,EAAG;IACZ,IAAIC,EAAE;IACN,OAAO,CAACA,EAAE,GAAG,IAAI,CAACC,cAAc,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,IAAI,CAACtD,IAAI;EACvF;EACAuD,gBAAgBA,CAAA,EAAG;IACf,OAAO,IAAI,CAACF,cAAc,KAAKG,SAAS;EAC5C;EACAC,YAAYA,CAACzD,IAAI,EAAE;IACf,IAAIoD,EAAE;IACN,MAAMrC,QAAQ,GAAGN,eAAe,CAACT,IAAI,CAACE,OAAO,CAAC;IAC9C,MAAM,CAACwD,CAAC,EAAE5E,IAAI,CAAC,GAAG,IAAI,CAAC6E,OAAO,CAAC5C,QAAQ,CAAC;IACxC,IAAI,EAAEjC,IAAI,YAAYX,QAAQ,CAAC,EAAE;MAC7B;IACJ;IACA,IAAI,CAAC,CAACiF,EAAE,GAAG,IAAI,CAACC,cAAc,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,IAAI,MAAMxE,IAAI,EAAE;MACpF;IACJ;IACA,IAAI,IAAI,CAACyE,gBAAgB,CAAC,CAAC,EAAE;MACzB,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACAnC,mBAAmB,CAAC,IAAI,CAACoC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC1E,WAAW,CAAC;IACrD,MAAM2E,gBAAgB,GAAG,EAAE;IAC3B,SAASC,eAAeA,CAACC,MAAM,EAAEC,OAAO,EAAE;MACtC,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,MAAM,CAACtF,QAAQ,CAACC,MAAM,EAAEc,CAAC,EAAE,EAAE;QAC7C,MAAMC,KAAK,GAAGsE,MAAM,CAACtF,QAAQ,CAACe,CAAC,CAAC;QAChC,IAAIC,KAAK,YAAYvB,QAAQ,EAAE;UAC3B,IAAIuB,KAAK,KAAKuE,OAAO,EAAE;YACnB,IAAID,MAAM,CAACE,cAAc,CAACzE,CAAC,CAAC,EAAE;cAC1BuE,MAAM,CAACG,eAAe,CAAC1E,CAAC,EAAE,KAAK,CAAC;YACpC,CAAC,MACI;cACDqE,gBAAgB,CAACb,IAAI,CAACvD,KAAK,CAAC;YAChC;UACJ;QACJ,CAAC,MACI;UACDqE,eAAe,CAACrE,KAAK,EAAEuE,OAAO,CAAC;QACnC;MACJ;IACJ;IACAF,eAAe,CAAC,IAAI,CAACzB,IAAI,EAAExD,IAAI,CAAC;IAChC,IAAI,CAACuE,cAAc,GAAG;MAAEC,IAAI,EAAExE,IAAI;MAAEgF;IAAiB,CAAC;IACtD,IAAI,CAACM,yBAAyB,CAACC,IAAI,CAAC;MAChCrE,IAAI,EAAElB,IAAI,CAACkB,IAAI;MACfsE,WAAW,EAAE;IACjB,CAAC,CAAC;EACN;EACAV,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAACP,cAAc,EAAE;MACtB;IACJ;IACA,MAAMS,gBAAgB,GAAG,IAAI,CAACT,cAAc,CAACS,gBAAgB;IAC7D,SAASS,uBAAuBA,CAACP,MAAM,EAAE;MACrC,KAAK,IAAI1D,KAAK,GAAG0D,MAAM,CAACtF,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE2B,KAAK,IAAI,CAAC,EAAEA,KAAK,EAAE,EAAE;QAC9D,MAAMZ,KAAK,GAAGsE,MAAM,CAACtF,QAAQ,CAAC4B,KAAK,CAAC;QACpC,IAAIZ,KAAK,YAAYvB,QAAQ,EAAE;UAC3B,IAAI,CAAC2F,gBAAgB,CAACU,QAAQ,CAAC9E,KAAK,CAAC,EAAE;YACnCsE,MAAM,CAACG,eAAe,CAAC7D,KAAK,EAAE,IAAI,CAAC;UACvC;QACJ,CAAC,MACI;UACDiE,uBAAuB,CAAC7E,KAAK,CAAC;QAClC;MACJ;IACJ;IACA6E,uBAAuB,CAAC,IAAI,CAACjC,IAAI,CAAC;IAClC,MAAMmC,GAAG,GAAG,IAAI,CAACpB,cAAc,CAACC,IAAI;IACpC,IAAI,CAACD,cAAc,GAAGG,SAAS;IAC/B,IAAI,CAACY,yBAAyB,CAACC,IAAI,CAAC;MAChCrE,IAAI,EAAEyE,GAAG,CAACzE,IAAI;MACdsE,WAAW,EAAE;IACjB,CAAC,CAAC;EACN;EACAI,SAASA,CAAA,EAAG;IACR,MAAMvB,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,CAAC;IAC1C,IAAIwB,oBAAoB;IACxB,IAAIxB,aAAa,EAAE;MACf;AACZ;AACA;AACA;MACYwB,oBAAoB,GAAGlE,eAAe,CAAC0C,aAAa,CAACjD,OAAO,CAAC;IACjE;IACA,IAAI,IAAI,CAACqD,gBAAgB,CAAC,CAAC,EAAE;MACzB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;MACY,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACA,MAAMtB,IAAI,GAAGb,mBAAmB,CAAC,IAAI,CAACoC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC1E,WAAW,CAAC;IAClE,MAAMyF,OAAO,GAAG;MACZtC,IAAI;MACJX,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBzC,WAAW,EAAE,IAAI,CAACA;IACtB,CAAC;IACD,IAAIwF,oBAAoB,EAAE;MACtBC,OAAO,CAACC,aAAa,GAAG;QACpB9D,QAAQ,EAAE4D;MACd,CAAC;IACL;IACA,IAAIxB,aAAa,EAAE;MACf;MACA,IAAI,CAACM,YAAY,CAACN,aAAa,CAAC;IACpC;IACA,OAAOyB,OAAO;EAClB;EACAE,OAAOA,CAAA,EAAG;IACN,IAAI,CAACC,UAAU,CAACD,OAAO,CAAC,CAAC;IACzB,IAAI,CAACE,YAAY,CAACF,OAAO,CAAC,CAAC;IAC3B,IAAI,CAACV,yBAAyB,CAACU,OAAO,CAAC,CAAC;IACxC,IAAI,CAACG,0BAA0B,CAACH,OAAO,CAAC,CAAC;IACzC,IAAI,CAACxC,IAAI,CAACwC,OAAO,CAAC,CAAC;IACnB,IAAI,CAACzB,cAAc,GAAGG,SAAS;IAC/B,IAAI,CAACtD,OAAO,CAACgF,MAAM,CAAC,CAAC;EACzB;EACAC,KAAKA,CAAA,EAAG;IACJ,MAAMhG,WAAW,GAAG,IAAI,CAACmD,IAAI,CAACnD,WAAW;IACzC,IAAI,CAACmD,IAAI,GAAG,IAAIlE,UAAU,CAACe,WAAW,EAAE,IAAI,CAACC,kBAAkB,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACiD,IAAI,CAACvD,IAAI,EAAE,IAAI,CAACuD,IAAI,CAACtD,cAAc,EAAE,IAAI,CAAC4D,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC;EACrJ;EACA6F,WAAWA,CAACC,IAAI,EAAEC,YAAY,EAAE;IAC5B,MAAMnG,WAAW,GAAGkG,IAAI,CAAClG,WAAW;IACpC,MAAMyC,MAAM,GAAGzC,WAAW,KAAKnB,WAAW,CAACsD,QAAQ,GAAG+D,IAAI,CAACzD,MAAM,GAAGyD,IAAI,CAAC1D,KAAK;IAC9E,IAAI,CAAC4D,YAAY,CAACF,IAAI,CAAC/C,IAAI,EAAEnD,WAAW,EAAEmG,YAAY,EAAE1D,MAAM,CAAC;IAC/D;AACR;AACA;AACA;IACQ,IAAI,CAACW,MAAM,CAAC8C,IAAI,CAAC1D,KAAK,EAAE0D,IAAI,CAACzD,MAAM,CAAC;IACpC,IAAIyD,IAAI,CAACR,aAAa,EAAE;MACpB,MAAM9D,QAAQ,GAAGsE,IAAI,CAACR,aAAa,CAAC9D,QAAQ;MAC5C,MAAM,CAAC2C,CAAC,EAAE5E,IAAI,CAAC,GAAG,IAAI,CAAC6E,OAAO,CAAC5C,QAAQ,CAAC;MACxC,IAAI,EAAEjC,IAAI,YAAYX,QAAQ,CAAC,EAAE;QAC7B;MACJ;MACA,IAAI,CAACsF,YAAY,CAAC3E,IAAI,CAACkB,IAAI,CAAC;IAChC;EACJ;EACAuF,YAAYA,CAACjD,IAAI,EAAEnD,WAAW,EAAEmG,YAAY,EAAEtG,cAAc,EAAE;IAC1D,IAAI,CAACsD,IAAI,GAAG,IAAI,CAACkD,gBAAgB,CAAClD,IAAI,EAAEnD,WAAW,EAAEmG,YAAY,EAAEtG,cAAc,CAAC;EACtF;EACAwG,gBAAgBA,CAAC1G,IAAI,EAAEK,WAAW,EAAEmG,YAAY,EAAEtG,cAAc,EAAE;IAC9D,IAAIoE,EAAE;IACN,IAAInE,MAAM;IACV,IAAIH,IAAI,CAACgD,IAAI,KAAK,QAAQ,EAAE;MACxB,MAAM2D,kBAAkB,GAAG3G,IAAI,CAACiD,IAAI;MACpC,MAAMrD,QAAQ,GAAG+G,kBAAkB,CAACvD,GAAG,CAAEwD,eAAe,IAAK;QACzD,OAAO;UACH5G,IAAI,EAAE,IAAI,CAAC0G,gBAAgB,CAACE,eAAe,EAAExG,UAAU,CAACC,WAAW,CAAC,EAAEmG,YAAY,EAAExG,IAAI,CAACC,IAAI,CAAC;UAC9FkD,OAAO,EAAEyD,eAAe,CAACzD;QAC7B,CAAC;MACL,CAAC,CAAC;MACFhD,MAAM,GAAG,IAAIb,UAAU,CAACe,WAAW,EAAE,IAAI,CAACC,kBAAkB,EAAE,IAAI,CAACC,MAAM,EAAEP,IAAI,CAACC,IAAI;MAAE;MACtFC,cAAc;MAAE;MAChB,IAAI,CAAC4D,MAAM,EAAE,IAAI,CAACrD,MAAM,EAAEb,QAAQ,CAAC;IACvC,CAAC,MACI;MACD,MAAMsB,IAAI,GAAGsF,YAAY,CAACK,QAAQ,CAAC7G,IAAI,CAAC;MACxC,IAAI,OAAOA,IAAI,CAACmD,OAAO,KAAK,SAAS,EAAE;QACnC,CAACmB,EAAE,GAAGpD,IAAI,CAAC4F,UAAU,MAAM,IAAI,IAAIxC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyC,IAAI,CAAC7F,IAAI,EAAElB,IAAI,CAACmD,OAAO,CAAC;MAC3F;MACAhD,MAAM,GAAG,IAAId,QAAQ,CAAC6B,IAAI,EAAEb,WAAW,EAAEH,cAAc,EAAEF,IAAI,CAACC,IAAI,CAAC;IACvE;IACA,OAAOE,MAAM;EACjB;EACA,IAAIqD,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACD,KAAK;EACrB;EACA,IAAIC,IAAIA,CAACA,IAAI,EAAE;IACX,MAAMwD,OAAO,GAAG,IAAI,CAACzD,KAAK;IAC1B,IAAIyD,OAAO,EAAE;MACTA,OAAO,CAAChB,OAAO,CAAC,CAAC;MACjB,IAAI,CAACzB,cAAc,GAAGG,SAAS;MAC/B,IAAI,CAACtD,OAAO,CAAC6F,WAAW,CAACD,OAAO,CAAC5F,OAAO,CAAC;IAC7C;IACA,IAAI,CAACmC,KAAK,GAAGC,IAAI;IACjB,IAAI,CAACpC,OAAO,CAAC8F,WAAW,CAAC,IAAI,CAAC3D,KAAK,CAACnC,OAAO,CAAC;IAC5C,IAAI,CAAC6E,UAAU,CAACjC,KAAK,GAAG,IAAI,CAACT,KAAK,CAAC4D,WAAW,CAAEC,CAAC,IAAK;MAClD,IAAI,CAAClB,YAAY,CAACX,IAAI,CAAC6B,CAAC,CAAC;IAC7B,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACIC,+BAA+BA,CAAA,EAAG;IAC9B,IAAI,CAAC,IAAI,CAAC9D,KAAK,EAAE;MACb;IACJ;IACA,MAAMyD,OAAO,GAAG,IAAI,CAACxD,IAAI;IACzBwD,OAAO,CAAC5F,OAAO,CAACgF,MAAM,CAAC,CAAC;IACxB,IAAI,CAAC7C,KAAK,GAAG,IAAIjE,UAAU,CAACc,UAAU,CAAC4G,OAAO,CAAC3G,WAAW,CAAC,EAAE,IAAI,CAACC,kBAAkB,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACiD,IAAI,CAACtD,cAAc,EAAE,IAAI,CAACsD,IAAI,CAACvD,IAAI,EAAE,IAAI,CAAC6D,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC;IACtK,IAAIuG,OAAO,CAACpH,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MAC/B;IAAA,CACH,MACI,IAAImH,OAAO,CAACpH,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MACpC;MACA,MAAMyH,cAAc,GAAGN,OAAO,CAACpH,QAAQ,CAAC,CAAC,CAAC;MAC1C,MAAMgB,KAAK,GAAGoG,OAAO,CAACC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;MACtCrG,KAAK,CAACoF,OAAO,CAAC,CAAC;MACfgB,OAAO,CAAChB,OAAO,CAAC,CAAC;MACjB,IAAI,CAACzC,KAAK,CAACtC,QAAQ;MACnB;AACZ;AACA;AACA;AACA;AACA;MACYlB,QAAQ,CAACuH,cAAc,EAAEA,cAAc,CAACpH,cAAc,EAAEoH,cAAc,CAACrH,IAAI,CAAC,EAAEd,MAAM,CAACoI,UAAU,EAAE,CAAC,CAAC;IACvG,CAAC,MACI;MACD,IAAI,CAAChE,KAAK,CAACtC,QAAQ,CAAC+F,OAAO,EAAE7H,MAAM,CAACoI,UAAU,EAAE,CAAC,CAAC;IACtD;IACA,IAAI,CAACnG,OAAO,CAAC8F,WAAW,CAAC,IAAI,CAAC3D,KAAK,CAACnC,OAAO,CAAC;IAC5C,IAAI,CAAC6E,UAAU,CAACjC,KAAK,GAAG,IAAI,CAACT,KAAK,CAAC4D,WAAW,CAAEC,CAAC,IAAK;MAClD,IAAI,CAAClB,YAAY,CAACX,IAAI,CAAC6B,CAAC,CAAC;IAC7B,CAAC,CAAC;EACN;EACAI,IAAIA,CAACvF,QAAQ,EAAE;IACX,OAAO,IAAI,CAACwF,eAAe,CAACxF,QAAQ,CAAC;EACzC;EACAyF,QAAQA,CAACzF,QAAQ,EAAE;IACf,OAAO,IAAI,CAACwF,eAAe,CAACxF,QAAQ,EAAE,IAAI,CAAC;EAC/C;EACA8C,OAAOA,CAAC9C,QAAQ,EAAE;IACd,MAAMjC,IAAI,GAAGiC,QAAQ,GAAG,IAAI,CAAC4C,OAAO,CAAC5C,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACuB,IAAI;IAC7D,OAAO,IAAI,CAACmE,SAAS,CAAC3H,IAAI,EAAE,IAAI,CAACK,WAAW,CAAC;EACjD;EACAsH,SAASA,CAAC3H,IAAI,EAAEK,WAAW,EAAE0C,iBAAiB,EAAE;IAC5C,MAAMH,GAAG,GAAG;MAAEE,MAAM,EAAE9C,IAAI,CAAC8C,MAAM;MAAED,KAAK,EAAE7C,IAAI,CAAC6C;IAAM,CAAC;IACtD,IAAI7C,IAAI,YAAYX,QAAQ,EAAE;MAC1B,OAAO;QAAEuD,GAAG;QAAE1B,IAAI,EAAElB,IAAI,CAACkB,IAAI;QAAE6B;MAAkB,CAAC;IACtD;IACA,MAAMnD,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACJ,QAAQ,CAACC,MAAM,EAAEc,CAAC,EAAE,EAAE;MAC3C,MAAMC,KAAK,GAAGZ,IAAI,CAACJ,QAAQ,CAACe,CAAC,CAAC;MAC9B,MAAMiH,qBAAqB,GAAG5H,IAAI,CAAC6H,yBAAyB,CAAClH,CAAC,CAAC;MAC/Df,QAAQ,CAACuE,IAAI,CAAC,IAAI,CAACwD,SAAS,CAAC/G,KAAK,EAAER,UAAU,CAACC,WAAW,CAAC,EAAEuH,qBAAqB,CAAC,CAAC;IACxF;IACA,OAAO;MAAEhF,GAAG;MAAEhD;IAAS,CAAC;EAC5B;EACA6H,eAAeA,CAACxF,QAAQ,EAAE6F,OAAO,GAAG,KAAK,EAAE;IACvC,MAAM,CAACC,IAAI,EAAE/H,IAAI,CAAC,GAAG,IAAI,CAAC6E,OAAO,CAAC5C,QAAQ,CAAC;IAC3C,IAAI,EAAEjC,IAAI,YAAYX,QAAQ,CAAC,EAAE;MAC7B,MAAM,IAAIS,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,KAAK,IAAIa,CAAC,GAAGoH,IAAI,CAAClI,MAAM,GAAG,CAAC,EAAEc,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvC,MAAMqH,CAAC,GAAGD,IAAI,CAACpH,CAAC,CAAC;MACjB,MAAMsH,CAAC,GAAGhG,QAAQ,CAACtB,CAAC,CAAC,IAAI,CAAC;MAC1B,MAAMuH,yBAAyB,GAAGJ,OAAO,GACnCG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GACVA,CAAC,GAAG,CAAC,GAAGD,CAAC,CAACpI,QAAQ,CAACC,MAAM;MAC/B,IAAIqI,yBAAyB,EAAE;QAC3B,OAAOzI,QAAQ,CAACuI,CAAC,CAACpI,QAAQ,CAACkI,OAAO,GAAGG,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAC,EAAEH,OAAO,CAAC;MACjE;IACJ;IACA,OAAOrI,QAAQ,CAAC,IAAI,CAAC+D,IAAI,EAAEsE,OAAO,CAAC;EACvC;EACAK,WAAWA,CAAC7H,kBAAkB,EAAEC,MAAM,EAAEF,WAAW,EAAEyD,MAAM,EAAErD,MAAM,EAAE;IACjE,IAAI,CAACH,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACwD,OAAO,GAAG,KAAK;IACpB,IAAI,CAACK,OAAO,GAAG,CAAC;IAChB,IAAI,CAACG,cAAc,GAAGG,SAAS;IAC/B,IAAI,CAACuB,UAAU,GAAG,IAAIzG,iBAAiB,CAAC,CAAC;IACzC,IAAI,CAAC0G,YAAY,GAAG,IAAI3G,OAAO,CAAC,CAAC;IACjC,IAAI,CAAC4H,WAAW,GAAG,IAAI,CAACjB,YAAY,CAACkC,KAAK;IAC1C,IAAI,CAACjC,0BAA0B,GAAG,IAAI5G,OAAO,CAAC,CAAC;IAC/C,IAAI,CAAC8I,yBAAyB,GAAG,IAAI,CAAClC,0BAA0B,CAACiC,KAAK;IACtE,IAAI,CAAC9C,yBAAyB,GAAG,IAAI/F,OAAO,CAAC,CAAC;IAC9C,IAAI,CAAC+I,wBAAwB,GAAG,IAAI,CAAChD,yBAAyB,CAAC8C,KAAK;IACpE,IAAI,CAAChH,OAAO,GAAGmH,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC5C,IAAI,CAACpH,OAAO,CAACS,SAAS,GAAG,cAAc;IACvC,IAAI,CAACkC,OAAO,GAAGD,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAG,KAAK;IACpE,IAAI,CAACM,OAAO,GAAG3D,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAG,CAAC;IAChE,IAAI,CAAC+C,IAAI,GAAG,IAAIlE,UAAU,CAACe,WAAW,EAAEC,kBAAkB,EAAEC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACuD,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC;EACvG;EACAgI,aAAaA,CAACxG,QAAQ,EAAE;IACpB,MAAM,CAACK,IAAI,EAAEd,KAAK,CAAC,GAAGpC,IAAI,CAAC6C,QAAQ,CAAC;IACpC,MAAM,GAAGiD,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,CAACvC,IAAI,CAAC;IACrC,IAAI,EAAE4C,MAAM,YAAY5F,UAAU,CAAC,EAAE;MACjC,MAAM,IAAIQ,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA,OAAOoF,MAAM,CAACE,cAAc,CAAC5D,KAAK,CAAC;EACvC;EACAkH,cAAcA,CAACzG,QAAQ,EAAEkB,OAAO,EAAE;IAC9B,IAAI,IAAI,CAACsB,gBAAgB,CAAC,CAAC,EAAE;MACzB,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACA,MAAM,CAACxC,IAAI,EAAEd,KAAK,CAAC,GAAGpC,IAAI,CAAC6C,QAAQ,CAAC;IACpC,MAAM,GAAGiD,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,CAACvC,IAAI,CAAC;IACrC,IAAI,EAAE4C,MAAM,YAAY5F,UAAU,CAAC,EAAE;MACjC,MAAM,IAAIQ,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA,IAAI,CAACqG,0BAA0B,CAACZ,IAAI,CAAC,CAAC;IACtCL,MAAM,CAACG,eAAe,CAAC7D,KAAK,EAAE2B,OAAO,CAAC;EAC1C;EACAwF,QAAQA,CAACC,cAAc,EAAEC,IAAI,EAAEC,EAAE,EAAE;IAC/B,IAAI,IAAI,CAACrE,gBAAgB,CAAC,CAAC,EAAE;MACzB,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACA,MAAM,GAAGI,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,CAAC+D,cAAc,CAAC;IAC/C,IAAI,EAAE1D,MAAM,YAAY5F,UAAU,CAAC,EAAE;MACjC,MAAM,IAAIQ,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACAoF,MAAM,CAAC6D,SAAS,CAACF,IAAI,EAAEC,EAAE,CAAC;EAC9B;EACAE,OAAOA,CAAC9H,IAAI,EAAEjB,IAAI,EAAEgC,QAAQ,EAAE;IAC1B,IAAI,IAAI,CAACwC,gBAAgB,CAAC,CAAC,EAAE;MACzB,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACA,MAAM,CAACxC,IAAI,EAAEd,KAAK,CAAC,GAAGpC,IAAI,CAAC6C,QAAQ,CAAC;IACpC,MAAM,CAACgH,YAAY,EAAE/D,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,CAACvC,IAAI,CAAC;IACjD,IAAI4C,MAAM,YAAY5F,UAAU,EAAE;MAC9B,MAAMU,IAAI,GAAG,IAAIX,QAAQ,CAAC6B,IAAI,EAAEd,UAAU,CAAC8E,MAAM,CAAC7E,WAAW,CAAC,EAAE6E,MAAM,CAAChF,cAAc,CAAC;MACtFgF,MAAM,CAACjE,QAAQ,CAACjB,IAAI,EAAEC,IAAI,EAAEuB,KAAK,CAAC;IACtC,CAAC,MACI;MACD,MAAM,CAAC0H,WAAW,EAAE,GAAGtE,CAAC,CAAC,GAAG,CAAC,GAAGqE,YAAY,CAAC,CAACnB,OAAO,CAAC,CAAC;MACvD,MAAM,CAACqB,WAAW,EAAE,GAAGC,EAAE,CAAC,GAAG,CAAC,GAAG9G,IAAI,CAAC,CAACwF,OAAO,CAAC,CAAC;MAChD,IAAIuB,cAAc,GAAG,CAAC;MACtB,MAAMC,2BAA2B,GAAGJ,WAAW,CAACrB,yBAAyB,CAACsB,WAAW,CAAC;MACtF,IAAI,OAAOG,2BAA2B,KAAK,QAAQ,EAAE;QACjDD,cAAc,GAAGlK,MAAM,CAACoK,SAAS,CAACD,2BAA2B,CAAC;MAClE;MACA,MAAM1I,KAAK,GAAGsI,WAAW,CAACjC,WAAW,CAACkC,WAAW,CAAC;MAClDvI,KAAK,CAACoF,OAAO,CAAC,CAAC;MACf,MAAMwD,SAAS,GAAG,IAAIlK,UAAU,CAAC4F,MAAM,CAAC7E,WAAW,EAAE,IAAI,CAACC,kBAAkB,EAAE,IAAI,CAACC,MAAM,EAAE2E,MAAM,CAACjF,IAAI,EAAEiF,MAAM,CAAChF,cAAc,EAAE,IAAI,CAAC4D,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC;MACxJyI,WAAW,CAACjI,QAAQ,CAACuI,SAAS,EAAEtE,MAAM,CAACjF,IAAI,EAAEkJ,WAAW,CAAC;MACzD,MAAMM,UAAU,GAAG,IAAIpK,QAAQ,CAAC6F,MAAM,CAAChE,IAAI,EAAEgI,WAAW,CAAC7I,WAAW,EAAE6E,MAAM,CAACjF,IAAI,CAAC;MAClFuJ,SAAS,CAACvI,QAAQ,CAACwI,UAAU,EAAEJ,cAAc,EAAE,CAAC,CAAC;MACjD,IAAI,OAAOpJ,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAAC+C,IAAI,KAAK,OAAO,EAAE;QACnD/C,IAAI,GAAG;UAAE+C,IAAI,EAAE,OAAO;UAAExB,KAAK,EAAE;QAAE,CAAC;MACtC;MACA,MAAMxB,IAAI,GAAG,IAAIX,QAAQ,CAAC6B,IAAI,EAAEgI,WAAW,CAAC7I,WAAW,EAAE6E,MAAM,CAACjF,IAAI,CAAC;MACrEuJ,SAAS,CAACvI,QAAQ,CAACjB,IAAI,EAAEC,IAAI,EAAEuB,KAAK,CAAC;IACzC;EACJ;EACA4E,MAAMA,CAAClF,IAAI,EAAEwI,MAAM,EAAE;IACjB,MAAMzH,QAAQ,GAAGN,eAAe,CAACT,IAAI,CAACE,OAAO,CAAC;IAC9C,OAAO,IAAI,CAACuI,UAAU,CAAC1H,QAAQ,EAAEyH,MAAM,CAAC;EAC5C;EACAC,UAAUA,CAAC1H,QAAQ,EAAEyH,MAAM,EAAE;IACzB,IAAI,IAAI,CAACjF,gBAAgB,CAAC,CAAC,EAAE;MACzB,IAAI,CAACK,iBAAiB,CAAC,CAAC;IAC5B;IACA,MAAM,CAACxC,IAAI,EAAEd,KAAK,CAAC,GAAGpC,IAAI,CAAC6C,QAAQ,CAAC;IACpC,MAAM,CAACgH,YAAY,EAAE/D,MAAM,CAAC,GAAG,IAAI,CAACL,OAAO,CAACvC,IAAI,CAAC;IACjD,IAAI,EAAE4C,MAAM,YAAY5F,UAAU,CAAC,EAAE;MACjC,MAAM,IAAIQ,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,MAAM8J,YAAY,GAAG1E,MAAM,CAACtF,QAAQ,CAAC4B,KAAK,CAAC;IAC3C,IAAI,EAAEoI,YAAY,YAAYvK,QAAQ,CAAC,EAAE;MACrC,MAAM,IAAIS,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACAoF,MAAM,CAAC+B,WAAW,CAACzF,KAAK,EAAEkI,MAAM,CAAC;IACjCE,YAAY,CAAC5D,OAAO,CAAC,CAAC;IACtB,IAAId,MAAM,CAACtF,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO+J,YAAY,CAAC1I,IAAI;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA,MAAM2I,OAAO,GAAG3E,MAAM,CAACtF,QAAQ,CAAC,CAAC,CAAC;IAClC,IAAIqJ,YAAY,CAACpJ,MAAM,KAAK,CAAC,EAAE;MAC3B;MACA,IAAIgK,OAAO,YAAYxK,QAAQ,EAAE;QAC7B;QACA,OAAOuK,YAAY,CAAC1I,IAAI;MAC5B;MACA;MACA;MACA;MACAgE,MAAM,CAAC+B,WAAW,CAAC,CAAC,EAAEyC,MAAM,CAAC;MAC7B;MACA,IAAI,CAAClG,IAAI,GAAGqG,OAAO;MACnB,OAAOD,YAAY,CAAC1I,IAAI;IAC5B;IACA;IACA,MAAM,CAACgI,WAAW,EAAE,GAAGtE,CAAC,CAAC,GAAG,CAAC,GAAGqE,YAAY,CAAC,CAACnB,OAAO,CAAC,CAAC;IACvD,MAAM,CAACqB,WAAW,EAAE,GAAGC,EAAE,CAAC,GAAG,CAAC,GAAG9G,IAAI,CAAC,CAACwF,OAAO,CAAC,CAAC;IAChD,MAAMgC,gBAAgB,GAAG5E,MAAM,CAACE,cAAc,CAAC,CAAC,CAAC;IACjD;IACAF,MAAM,CAAC+B,WAAW,CAAC,CAAC,EAAEyC,MAAM,CAAC;IAC7B;IACA,MAAMK,KAAK,GAAGb,WAAW,CAACtJ,QAAQ,CAACwD,GAAG,CAAC,CAAC4G,KAAK,EAAErJ,CAAC,KAAKuI,WAAW,CAACe,YAAY,CAACtJ,CAAC,CAAC,CAAC;IACjF;IACA;IACAuI,WAAW,CAACjC,WAAW,CAACkC,WAAW,EAAEO,MAAM,CAAC,CAAC1D,OAAO,CAAC,CAAC;IACtD,IAAI6D,OAAO,YAAYvK,UAAU,EAAE;MAC/B;MACAyK,KAAK,CAACG,MAAM,CAACf,WAAW,EAAE,CAAC,EAAE,GAAGU,OAAO,CAACjK,QAAQ,CAACwD,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACpD,IAAI,CAAC,CAAC;MACpE;MACA,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkJ,OAAO,CAACjK,QAAQ,CAACC,MAAM,EAAEc,CAAC,EAAE,EAAE;QAC9C,MAAMC,KAAK,GAAGiJ,OAAO,CAACjK,QAAQ,CAACe,CAAC,CAAC;QACjCuI,WAAW,CAACjI,QAAQ,CAACL,KAAK,EAAEA,KAAK,CAACX,IAAI,EAAEkJ,WAAW,GAAGxI,CAAC,CAAC;MAC5D;MACA;AACZ;AACA;AACA;AACA;MACY,OAAOkJ,OAAO,CAACjK,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;QAChCgK,OAAO,CAAC5C,WAAW,CAAC,CAAC,CAAC;MAC1B;IACJ,CAAC,MACI;MACD;MACA,MAAMwC,UAAU,GAAG,IAAIpK,QAAQ,CAACwK,OAAO,CAAC3I,IAAI,EAAEd,UAAU,CAACyJ,OAAO,CAACxJ,WAAW,CAAC,EAAEwJ,OAAO,CAAC5J,IAAI,CAAC;MAC5F,MAAMkK,aAAa,GAAGL,gBAAgB,GAChCD,OAAO,CAAC3J,cAAc,GACtBf,MAAM,CAACoK,SAAS,CAACM,OAAO,CAAC3J,cAAc,CAAC;MAC9CgJ,WAAW,CAACjI,QAAQ,CAACwI,UAAU,EAAEU,aAAa,EAAEhB,WAAW,CAAC;IAChE;IACA;IACAU,OAAO,CAAC7D,OAAO,CAAC,CAAC;IACjB;IACA,KAAK,IAAIrF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoJ,KAAK,CAAClK,MAAM,EAAEc,CAAC,EAAE,EAAE;MACnCuI,WAAW,CAACkB,WAAW,CAACzJ,CAAC,EAAEoJ,KAAK,CAACpJ,CAAC,CAAC,CAAC;IACxC;IACA,OAAOiJ,YAAY,CAAC1I,IAAI;EAC5B;EACAuC,MAAMA,CAACZ,KAAK,EAAEC,MAAM,EAAE;IAClB,MAAM,CAAC7C,IAAI,EAAEC,cAAc,CAAC,GAAG,IAAI,CAACsD,IAAI,CAACnD,WAAW,KAAKnB,WAAW,CAACuD,UAAU,GACzE,CAACK,MAAM,EAAED,KAAK,CAAC,GACf,CAACA,KAAK,EAAEC,MAAM,CAAC;IACrB,IAAI,CAACU,IAAI,CAACC,MAAM,CAACxD,IAAI,EAAEC,cAAc,CAAC;EAC1C;EACA2E,OAAOA,CAAC5C,QAAQ,EAAEjC,IAAI,GAAG,IAAI,CAACwD,IAAI,EAAEuE,IAAI,GAAG,EAAE,EAAE;IAC3C,IAAI9F,QAAQ,CAACpC,MAAM,KAAK,CAAC,EAAE;MACvB,OAAO,CAACkI,IAAI,EAAE/H,IAAI,CAAC;IACvB;IACA,IAAI,EAAEA,IAAI,YAAYV,UAAU,CAAC,EAAE;MAC/B,MAAM,IAAIQ,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,MAAM,CAAC0B,KAAK,EAAE,GAAGc,IAAI,CAAC,GAAGL,QAAQ;IACjC,IAAIT,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAIxB,IAAI,CAACJ,QAAQ,CAACC,MAAM,EAAE;MAC5C,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,MAAMc,KAAK,GAAGZ,IAAI,CAACJ,QAAQ,CAAC4B,KAAK,CAAC;IAClCuG,IAAI,CAAC5D,IAAI,CAACnE,IAAI,CAAC;IACf,OAAO,IAAI,CAAC6E,OAAO,CAACvC,IAAI,EAAE1B,KAAK,EAAEmH,IAAI,CAAC;EAC1C;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}