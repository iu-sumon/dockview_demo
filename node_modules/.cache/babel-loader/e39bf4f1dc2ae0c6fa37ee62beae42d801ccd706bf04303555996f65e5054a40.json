{"ast":null,"code":"import { DragAndDropObserver } from '../dnd/dnd';\nimport { getDomNodePagePosition, toggleClass } from '../dom';\nimport { CompositeDisposable, Disposable, MutableDisposable } from '../lifecycle';\nfunction createFocusableElement() {\n  const element = document.createElement('div');\n  element.tabIndex = -1;\n  return element;\n}\nexport class OverlayRenderContainer extends CompositeDisposable {\n  constructor(element, accessor) {\n    super();\n    this.element = element;\n    this.accessor = accessor;\n    this.map = {};\n    this._disposed = false;\n    this.addDisposables(Disposable.from(() => {\n      for (const value of Object.values(this.map)) {\n        value.disposable.dispose();\n        value.destroy.dispose();\n      }\n      this._disposed = true;\n    }));\n  }\n  detatch(panel) {\n    if (this.map[panel.api.id]) {\n      const {\n        disposable,\n        destroy\n      } = this.map[panel.api.id];\n      disposable.dispose();\n      destroy.dispose();\n      delete this.map[panel.api.id];\n      return true;\n    }\n    return false;\n  }\n  attach(options) {\n    const {\n      panel,\n      referenceContainer\n    } = options;\n    if (!this.map[panel.api.id]) {\n      const element = createFocusableElement();\n      element.className = 'dv-render-overlay';\n      this.map[panel.api.id] = {\n        panel,\n        disposable: Disposable.NONE,\n        destroy: Disposable.NONE,\n        element\n      };\n    }\n    const focusContainer = this.map[panel.api.id].element;\n    if (panel.view.content.element.parentElement !== focusContainer) {\n      focusContainer.appendChild(panel.view.content.element);\n    }\n    if (focusContainer.parentElement !== this.element) {\n      this.element.appendChild(focusContainer);\n    }\n    const resize = () => {\n      // TODO propagate position to avoid getDomNodePagePosition calls, possible performance bottleneck?\n      const box = getDomNodePagePosition(referenceContainer.element);\n      const box2 = getDomNodePagePosition(this.element);\n      focusContainer.style.left = `${box.left - box2.left}px`;\n      focusContainer.style.top = `${box.top - box2.top}px`;\n      focusContainer.style.width = `${box.width}px`;\n      focusContainer.style.height = `${box.height}px`;\n      toggleClass(focusContainer, 'dv-render-overlay-float', panel.group.api.location.type === 'floating');\n    };\n    const visibilityChanged = () => {\n      if (panel.api.isVisible) {\n        resize();\n      }\n      focusContainer.style.display = panel.api.isVisible ? '' : 'none';\n    };\n    const observerDisposable = new MutableDisposable();\n    const correctLayerPosition = () => {\n      if (panel.api.location.type === 'floating') {\n        queueMicrotask(() => {\n          const floatingGroup = this.accessor.floatingGroups.find(group => group.group === panel.api.group);\n          if (!floatingGroup) {\n            return;\n          }\n          const element = floatingGroup.overlay.element;\n          const update = () => {\n            const level = Number(element.getAttribute('aria-level'));\n            focusContainer.style.zIndex = `calc(var(--dv-overlay-z-index, 999) + ${level * 2 + 1})`;\n          };\n          const observer = new MutationObserver(() => {\n            update();\n          });\n          observerDisposable.value = Disposable.from(() => observer.disconnect());\n          observer.observe(element, {\n            attributeFilter: ['aria-level'],\n            attributes: true\n          });\n          update();\n        });\n      } else {\n        focusContainer.style.zIndex = ''; // reset the z-index, perhaps CSS will take over here\n      }\n    };\n    const disposable = new CompositeDisposable(observerDisposable,\n    /**\n     * since container is positioned absoutely we must explicitly forward\n     * the dnd events for the expect behaviours to continue to occur in terms of dnd\n     *\n     * the dnd observer does not need to be conditional on whether the panel is visible since\n     * non-visible panels are 'display: none' and in such case the dnd observer will not fire.\n     */\n    new DragAndDropObserver(focusContainer, {\n      onDragEnd: e => {\n        referenceContainer.dropTarget.dnd.onDragEnd(e);\n      },\n      onDragEnter: e => {\n        referenceContainer.dropTarget.dnd.onDragEnter(e);\n      },\n      onDragLeave: e => {\n        referenceContainer.dropTarget.dnd.onDragLeave(e);\n      },\n      onDrop: e => {\n        referenceContainer.dropTarget.dnd.onDrop(e);\n      },\n      onDragOver: e => {\n        referenceContainer.dropTarget.dnd.onDragOver(e);\n      }\n    }), panel.api.onDidVisibilityChange(() => {\n      /**\n       * Control the visibility of the content, however even when not visible (display: none)\n       * the content is still maintained within the DOM hence DOM specific attributes\n       * such as scroll position are maintained when next made visible.\n       */\n      visibilityChanged();\n    }), panel.api.onDidDimensionsChange(() => {\n      if (!panel.api.isVisible) {\n        return;\n      }\n      resize();\n    }), panel.api.onDidLocationChange(() => {\n      correctLayerPosition();\n    }));\n    this.map[panel.api.id].destroy = Disposable.from(() => {\n      var _a;\n      if (panel.view.content.element.parentElement === focusContainer) {\n        focusContainer.removeChild(panel.view.content.element);\n      }\n      (_a = focusContainer.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(focusContainer);\n    });\n    correctLayerPosition();\n    queueMicrotask(() => {\n      if (this.isDisposed) {\n        return;\n      }\n      /**\n       * wait until everything has finished in the current stack-frame call before\n       * calling the first resize as other size-altering events may still occur before\n       * the end of the stack-frame.\n       */\n      visibilityChanged();\n    });\n    // dispose of logic asoccciated with previous reference-container\n    this.map[panel.api.id].disposable.dispose();\n    // and reset the disposable to the active reference-container\n    this.map[panel.api.id].disposable = disposable;\n    return focusContainer;\n  }\n}","map":{"version":3,"names":["DragAndDropObserver","getDomNodePagePosition","toggleClass","CompositeDisposable","Disposable","MutableDisposable","createFocusableElement","element","document","createElement","tabIndex","OverlayRenderContainer","constructor","accessor","map","_disposed","addDisposables","from","value","Object","values","disposable","dispose","destroy","detatch","panel","api","id","attach","options","referenceContainer","className","NONE","focusContainer","view","content","parentElement","appendChild","resize","box","box2","style","left","top","width","height","group","location","type","visibilityChanged","isVisible","display","observerDisposable","correctLayerPosition","queueMicrotask","floatingGroup","floatingGroups","find","overlay","update","level","Number","getAttribute","zIndex","observer","MutationObserver","disconnect","observe","attributeFilter","attributes","onDragEnd","e","dropTarget","dnd","onDragEnter","onDragLeave","onDrop","onDragOver","onDidVisibilityChange","onDidDimensionsChange","onDidLocationChange","_a","removeChild","isDisposed"],"sources":["E:/dockview.demo/node_modules/dockview-core/dist/esm/overlay/overlayRenderContainer.js"],"sourcesContent":["import { DragAndDropObserver } from '../dnd/dnd';\nimport { getDomNodePagePosition, toggleClass } from '../dom';\nimport { CompositeDisposable, Disposable, MutableDisposable, } from '../lifecycle';\nfunction createFocusableElement() {\n    const element = document.createElement('div');\n    element.tabIndex = -1;\n    return element;\n}\nexport class OverlayRenderContainer extends CompositeDisposable {\n    constructor(element, accessor) {\n        super();\n        this.element = element;\n        this.accessor = accessor;\n        this.map = {};\n        this._disposed = false;\n        this.addDisposables(Disposable.from(() => {\n            for (const value of Object.values(this.map)) {\n                value.disposable.dispose();\n                value.destroy.dispose();\n            }\n            this._disposed = true;\n        }));\n    }\n    detatch(panel) {\n        if (this.map[panel.api.id]) {\n            const { disposable, destroy } = this.map[panel.api.id];\n            disposable.dispose();\n            destroy.dispose();\n            delete this.map[panel.api.id];\n            return true;\n        }\n        return false;\n    }\n    attach(options) {\n        const { panel, referenceContainer } = options;\n        if (!this.map[panel.api.id]) {\n            const element = createFocusableElement();\n            element.className = 'dv-render-overlay';\n            this.map[panel.api.id] = {\n                panel,\n                disposable: Disposable.NONE,\n                destroy: Disposable.NONE,\n                element,\n            };\n        }\n        const focusContainer = this.map[panel.api.id].element;\n        if (panel.view.content.element.parentElement !== focusContainer) {\n            focusContainer.appendChild(panel.view.content.element);\n        }\n        if (focusContainer.parentElement !== this.element) {\n            this.element.appendChild(focusContainer);\n        }\n        const resize = () => {\n            // TODO propagate position to avoid getDomNodePagePosition calls, possible performance bottleneck?\n            const box = getDomNodePagePosition(referenceContainer.element);\n            const box2 = getDomNodePagePosition(this.element);\n            focusContainer.style.left = `${box.left - box2.left}px`;\n            focusContainer.style.top = `${box.top - box2.top}px`;\n            focusContainer.style.width = `${box.width}px`;\n            focusContainer.style.height = `${box.height}px`;\n            toggleClass(focusContainer, 'dv-render-overlay-float', panel.group.api.location.type === 'floating');\n        };\n        const visibilityChanged = () => {\n            if (panel.api.isVisible) {\n                resize();\n            }\n            focusContainer.style.display = panel.api.isVisible ? '' : 'none';\n        };\n        const observerDisposable = new MutableDisposable();\n        const correctLayerPosition = () => {\n            if (panel.api.location.type === 'floating') {\n                queueMicrotask(() => {\n                    const floatingGroup = this.accessor.floatingGroups.find((group) => group.group === panel.api.group);\n                    if (!floatingGroup) {\n                        return;\n                    }\n                    const element = floatingGroup.overlay.element;\n                    const update = () => {\n                        const level = Number(element.getAttribute('aria-level'));\n                        focusContainer.style.zIndex = `calc(var(--dv-overlay-z-index, 999) + ${level * 2 + 1})`;\n                    };\n                    const observer = new MutationObserver(() => {\n                        update();\n                    });\n                    observerDisposable.value = Disposable.from(() => observer.disconnect());\n                    observer.observe(element, {\n                        attributeFilter: ['aria-level'],\n                        attributes: true,\n                    });\n                    update();\n                });\n            }\n            else {\n                focusContainer.style.zIndex = ''; // reset the z-index, perhaps CSS will take over here\n            }\n        };\n        const disposable = new CompositeDisposable(observerDisposable, \n        /**\n         * since container is positioned absoutely we must explicitly forward\n         * the dnd events for the expect behaviours to continue to occur in terms of dnd\n         *\n         * the dnd observer does not need to be conditional on whether the panel is visible since\n         * non-visible panels are 'display: none' and in such case the dnd observer will not fire.\n         */\n        new DragAndDropObserver(focusContainer, {\n            onDragEnd: (e) => {\n                referenceContainer.dropTarget.dnd.onDragEnd(e);\n            },\n            onDragEnter: (e) => {\n                referenceContainer.dropTarget.dnd.onDragEnter(e);\n            },\n            onDragLeave: (e) => {\n                referenceContainer.dropTarget.dnd.onDragLeave(e);\n            },\n            onDrop: (e) => {\n                referenceContainer.dropTarget.dnd.onDrop(e);\n            },\n            onDragOver: (e) => {\n                referenceContainer.dropTarget.dnd.onDragOver(e);\n            },\n        }), panel.api.onDidVisibilityChange(() => {\n            /**\n             * Control the visibility of the content, however even when not visible (display: none)\n             * the content is still maintained within the DOM hence DOM specific attributes\n             * such as scroll position are maintained when next made visible.\n             */\n            visibilityChanged();\n        }), panel.api.onDidDimensionsChange(() => {\n            if (!panel.api.isVisible) {\n                return;\n            }\n            resize();\n        }), panel.api.onDidLocationChange(() => {\n            correctLayerPosition();\n        }));\n        this.map[panel.api.id].destroy = Disposable.from(() => {\n            var _a;\n            if (panel.view.content.element.parentElement === focusContainer) {\n                focusContainer.removeChild(panel.view.content.element);\n            }\n            (_a = focusContainer.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(focusContainer);\n        });\n        correctLayerPosition();\n        queueMicrotask(() => {\n            if (this.isDisposed) {\n                return;\n            }\n            /**\n             * wait until everything has finished in the current stack-frame call before\n             * calling the first resize as other size-altering events may still occur before\n             * the end of the stack-frame.\n             */\n            visibilityChanged();\n        });\n        // dispose of logic asoccciated with previous reference-container\n        this.map[panel.api.id].disposable.dispose();\n        // and reset the disposable to the active reference-container\n        this.map[panel.api.id].disposable = disposable;\n        return focusContainer;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}