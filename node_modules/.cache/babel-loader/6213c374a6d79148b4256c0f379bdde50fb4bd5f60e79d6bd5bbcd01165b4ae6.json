{"ast":null,"code":"export var Event;\n(function (Event) {\n  Event.any = (...children) => {\n    return listener => {\n      const disposables = children.map(child => child(listener));\n      return {\n        dispose: () => {\n          disposables.forEach(d => {\n            d.dispose();\n          });\n        }\n      };\n    };\n  };\n})(Event || (Event = {}));\nexport class DockviewEvent {\n  constructor() {\n    this._defaultPrevented = false;\n  }\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  preventDefault() {\n    this._defaultPrevented = true;\n  }\n}\nexport class AcceptableEvent {\n  constructor() {\n    this._isAccepted = false;\n  }\n  get isAccepted() {\n    return this._isAccepted;\n  }\n  accept() {\n    this._isAccepted = true;\n  }\n}\nclass LeakageMonitor {\n  constructor() {\n    this.events = new Map();\n  }\n  get size() {\n    return this.events.size;\n  }\n  add(event, stacktrace) {\n    this.events.set(event, stacktrace);\n  }\n  delete(event) {\n    this.events.delete(event);\n  }\n  clear() {\n    this.events.clear();\n  }\n}\nclass Stacktrace {\n  static create() {\n    var _a;\n    return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn('dockview: stacktrace', this.value);\n  }\n}\nclass Listener {\n  constructor(callback, stacktrace) {\n    this.callback = callback;\n    this.stacktrace = stacktrace;\n  }\n}\n// relatively simple event emitter taken from https://github.com/microsoft/vscode/blob/master/src/vs/base/common/event.ts\nexport class Emitter {\n  static setLeakageMonitorEnabled(isEnabled) {\n    if (isEnabled !== Emitter.ENABLE_TRACKING) {\n      Emitter.MEMORY_LEAK_WATCHER.clear();\n    }\n    Emitter.ENABLE_TRACKING = isEnabled;\n  }\n  get value() {\n    return this._last;\n  }\n  constructor(options) {\n    this.options = options;\n    this._listeners = [];\n    this._disposed = false;\n  }\n  get event() {\n    if (!this._event) {\n      this._event = callback => {\n        var _a;\n        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.replay) && this._last !== undefined) {\n          callback(this._last);\n        }\n        const listener = new Listener(callback, Emitter.ENABLE_TRACKING ? Stacktrace.create() : undefined);\n        this._listeners.push(listener);\n        return {\n          dispose: () => {\n            const index = this._listeners.indexOf(listener);\n            if (index > -1) {\n              this._listeners.splice(index, 1);\n            } else if (Emitter.ENABLE_TRACKING) {\n              // console.warn(\n              //     `dockview: listener already disposed`,\n              //     Stacktrace.create().print()\n              // );\n            }\n          }\n        };\n      };\n      if (Emitter.ENABLE_TRACKING) {\n        Emitter.MEMORY_LEAK_WATCHER.add(this._event, Stacktrace.create());\n      }\n    }\n    return this._event;\n  }\n  fire(e) {\n    var _a;\n    if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.replay) {\n      this._last = e;\n    }\n    for (const listener of this._listeners) {\n      listener.callback(e);\n    }\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      if (this._listeners.length > 0) {\n        if (Emitter.ENABLE_TRACKING) {\n          queueMicrotask(() => {\n            var _a;\n            // don't check until stack of execution is completed to allow for out-of-order disposals within the same execution block\n            for (const listener of this._listeners) {\n              console.warn('dockview: stacktrace', (_a = listener.stacktrace) === null || _a === void 0 ? void 0 : _a.print());\n            }\n          });\n        }\n        this._listeners = [];\n      }\n      if (Emitter.ENABLE_TRACKING && this._event) {\n        Emitter.MEMORY_LEAK_WATCHER.delete(this._event);\n      }\n    }\n  }\n}\nEmitter.ENABLE_TRACKING = false;\nEmitter.MEMORY_LEAK_WATCHER = new LeakageMonitor();\nexport function addDisposableListener(element, type, listener, options) {\n  element.addEventListener(type, listener, options);\n  return {\n    dispose: () => {\n      element.removeEventListener(type, listener, options);\n    }\n  };\n}\n/**\n *\n * Event Emitter that fires events from a Microtask callback, only one event will fire per event-loop cycle.\n *\n * It's kind of like using an `asapScheduler` in RxJs with additional logic to only fire once per event-loop cycle.\n * This implementation exists to avoid external dependencies.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask\n * @see https://rxjs.dev/api/index/const/asapScheduler\n */\nexport class AsapEvent {\n  constructor() {\n    this._onFired = new Emitter();\n    this._currentFireCount = 0;\n    this._queued = false;\n    this.onEvent = e => {\n      /**\n       * when the event is first subscribed to take note of the current fire count\n       */\n      const fireCountAtTimeOfEventSubscription = this._currentFireCount;\n      return this._onFired.event(() => {\n        /**\n         * if the current fire count is greater than the fire count at event subscription\n         * then the event has been fired since we subscribed and it's ok to \"on_next\" the event.\n         *\n         * if the count is not greater then what we are recieving is an event from the microtask\n         * queue that was triggered before we actually subscribed and therfore we should ignore it.\n         */\n        if (this._currentFireCount > fireCountAtTimeOfEventSubscription) {\n          e();\n        }\n      });\n    };\n  }\n  fire() {\n    this._currentFireCount++;\n    if (this._queued) {\n      return;\n    }\n    this._queued = true;\n    queueMicrotask(() => {\n      this._queued = false;\n      this._onFired.fire();\n    });\n  }\n  dispose() {\n    this._onFired.dispose();\n  }\n}","map":{"version":3,"names":["Event","any","children","listener","disposables","map","child","dispose","forEach","d","DockviewEvent","constructor","_defaultPrevented","defaultPrevented","preventDefault","AcceptableEvent","_isAccepted","isAccepted","accept","LeakageMonitor","events","Map","size","add","event","stacktrace","set","delete","clear","Stacktrace","create","_a","Error","stack","value","print","console","warn","Listener","callback","Emitter","setLeakageMonitorEnabled","isEnabled","ENABLE_TRACKING","MEMORY_LEAK_WATCHER","_last","options","_listeners","_disposed","_event","replay","undefined","push","index","indexOf","splice","fire","e","length","queueMicrotask","addDisposableListener","element","type","addEventListener","removeEventListener","AsapEvent","_onFired","_currentFireCount","_queued","onEvent","fireCountAtTimeOfEventSubscription"],"sources":["E:/dockview.demo/node_modules/dockview-core/dist/esm/events.js"],"sourcesContent":["export var Event;\n(function (Event) {\n    Event.any = (...children) => {\n        return (listener) => {\n            const disposables = children.map((child) => child(listener));\n            return {\n                dispose: () => {\n                    disposables.forEach((d) => {\n                        d.dispose();\n                    });\n                },\n            };\n        };\n    };\n})(Event || (Event = {}));\nexport class DockviewEvent {\n    constructor() {\n        this._defaultPrevented = false;\n    }\n    get defaultPrevented() {\n        return this._defaultPrevented;\n    }\n    preventDefault() {\n        this._defaultPrevented = true;\n    }\n}\nexport class AcceptableEvent {\n    constructor() {\n        this._isAccepted = false;\n    }\n    get isAccepted() {\n        return this._isAccepted;\n    }\n    accept() {\n        this._isAccepted = true;\n    }\n}\nclass LeakageMonitor {\n    constructor() {\n        this.events = new Map();\n    }\n    get size() {\n        return this.events.size;\n    }\n    add(event, stacktrace) {\n        this.events.set(event, stacktrace);\n    }\n    delete(event) {\n        this.events.delete(event);\n    }\n    clear() {\n        this.events.clear();\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn('dockview: stacktrace', this.value);\n    }\n}\nclass Listener {\n    constructor(callback, stacktrace) {\n        this.callback = callback;\n        this.stacktrace = stacktrace;\n    }\n}\n// relatively simple event emitter taken from https://github.com/microsoft/vscode/blob/master/src/vs/base/common/event.ts\nexport class Emitter {\n    static setLeakageMonitorEnabled(isEnabled) {\n        if (isEnabled !== Emitter.ENABLE_TRACKING) {\n            Emitter.MEMORY_LEAK_WATCHER.clear();\n        }\n        Emitter.ENABLE_TRACKING = isEnabled;\n    }\n    get value() {\n        return this._last;\n    }\n    constructor(options) {\n        this.options = options;\n        this._listeners = [];\n        this._disposed = false;\n    }\n    get event() {\n        if (!this._event) {\n            this._event = (callback) => {\n                var _a;\n                if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.replay) && this._last !== undefined) {\n                    callback(this._last);\n                }\n                const listener = new Listener(callback, Emitter.ENABLE_TRACKING ? Stacktrace.create() : undefined);\n                this._listeners.push(listener);\n                return {\n                    dispose: () => {\n                        const index = this._listeners.indexOf(listener);\n                        if (index > -1) {\n                            this._listeners.splice(index, 1);\n                        }\n                        else if (Emitter.ENABLE_TRACKING) {\n                            // console.warn(\n                            //     `dockview: listener already disposed`,\n                            //     Stacktrace.create().print()\n                            // );\n                        }\n                    },\n                };\n            };\n            if (Emitter.ENABLE_TRACKING) {\n                Emitter.MEMORY_LEAK_WATCHER.add(this._event, Stacktrace.create());\n            }\n        }\n        return this._event;\n    }\n    fire(e) {\n        var _a;\n        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.replay) {\n            this._last = e;\n        }\n        for (const listener of this._listeners) {\n            listener.callback(e);\n        }\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            if (this._listeners.length > 0) {\n                if (Emitter.ENABLE_TRACKING) {\n                    queueMicrotask(() => {\n                        var _a;\n                        // don't check until stack of execution is completed to allow for out-of-order disposals within the same execution block\n                        for (const listener of this._listeners) {\n                            console.warn('dockview: stacktrace', (_a = listener.stacktrace) === null || _a === void 0 ? void 0 : _a.print());\n                        }\n                    });\n                }\n                this._listeners = [];\n            }\n            if (Emitter.ENABLE_TRACKING && this._event) {\n                Emitter.MEMORY_LEAK_WATCHER.delete(this._event);\n            }\n        }\n    }\n}\nEmitter.ENABLE_TRACKING = false;\nEmitter.MEMORY_LEAK_WATCHER = new LeakageMonitor();\nexport function addDisposableListener(element, type, listener, options) {\n    element.addEventListener(type, listener, options);\n    return {\n        dispose: () => {\n            element.removeEventListener(type, listener, options);\n        },\n    };\n}\n/**\n *\n * Event Emitter that fires events from a Microtask callback, only one event will fire per event-loop cycle.\n *\n * It's kind of like using an `asapScheduler` in RxJs with additional logic to only fire once per event-loop cycle.\n * This implementation exists to avoid external dependencies.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask\n * @see https://rxjs.dev/api/index/const/asapScheduler\n */\nexport class AsapEvent {\n    constructor() {\n        this._onFired = new Emitter();\n        this._currentFireCount = 0;\n        this._queued = false;\n        this.onEvent = (e) => {\n            /**\n             * when the event is first subscribed to take note of the current fire count\n             */\n            const fireCountAtTimeOfEventSubscription = this._currentFireCount;\n            return this._onFired.event(() => {\n                /**\n                 * if the current fire count is greater than the fire count at event subscription\n                 * then the event has been fired since we subscribed and it's ok to \"on_next\" the event.\n                 *\n                 * if the count is not greater then what we are recieving is an event from the microtask\n                 * queue that was triggered before we actually subscribed and therfore we should ignore it.\n                 */\n                if (this._currentFireCount > fireCountAtTimeOfEventSubscription) {\n                    e();\n                }\n            });\n        };\n    }\n    fire() {\n        this._currentFireCount++;\n        if (this._queued) {\n            return;\n        }\n        this._queued = true;\n        queueMicrotask(() => {\n            this._queued = false;\n            this._onFired.fire();\n        });\n    }\n    dispose() {\n        this._onFired.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}